
#include <irrlicht.h>
#include <iostream>
#include "csg_classes.h"
#include "edit_env.h"
#include "tolerances.h"

//#include <math.h>

using namespace irr;

/*
core::aabbox3df polyfold::get_padded_bbox()
{
    core::aabbox3df ret = this->bbox;
    ret.
}
*/

geometry_scene::geometry_scene(scene::ISceneManager* smgr_,video::IVideoDriver* driver_)
{
    this->smgr = smgr_;
    this->driver = driver_;
    geo_element red;
    red.brush= make_poly_cube(256,256,256);
    red.type=GEO_RED;
    elements.push_back(red);
}

std::vector<int> geometry_scene::getSelection()
{
    return this->selection;
}
void geometry_scene::setSelection(std::vector<int> new_sel)
{
    this->selection=new_sel;

    for(int i=0; i<elements.size(); i++)
    {
        this->elements[i].bSelected=false;
    }

    for(int i: new_sel)
        this->elements[i].bSelected=true;
}

void geometry_scene::select(int s)
{
    for(int i=0;i<this->elements.size();i++)
    {
        if(i==s)
            this->elements[i].bSelected=true;
        else
            this->elements[i].bSelected=false;
    }
}

core::vector3df geometry_scene::getSelectedVertex()
{
    bool bSelectedVertex=false;
    core::vector3df ret = core::vector3df(0,0,0);

    for(int p_i :this->selection)
    {
        if(this->selected==p_i && this->elements[p_i].selected_vertex< this->elements[p_i].brush.vertices.size())
        {
            bSelectedVertex=true;
            ret=this->elements[p_i].brush.vertices[ this->elements[p_i].selected_vertex].V;
        }
    }
    if(!bSelectedVertex && this->elements.size()>0)
    {
        ret=this->elements[this->getSelection()[0]].brush.vertices[0].V;
    }
    return ret;
}

void geo_element::draw_brush(video::IVideoDriver* driver, const video::SMaterial material)
{
    video::SColor col = this->getColor();

    for(int i =0; i<this->brush.edges.size(); i++)
    {
        if(this->brush.edges[i].topo_group != -1)
            driver->draw3DLine(this->brush.getVertex(i,0).V,this->brush.getVertex(i,1).V,col);
    }
}
video::SColor geo_element::getColor()
{
    video::SColor col = video::SColor(128,128,128,128);

    if(this->bSelected==true)
    {
        if(this->type == GEO_ADD)
            col = COLOR_ADD_SELECTED;
        else if(this->type == GEO_SUBTRACT)
            col = COLOR_SUB_SELECTED;
        else if(this->type == GEO_RED)
            col = COLOR_RED_SELECTED;
    }
    else if(this->bSelected==false)
    {
        if(this->type == GEO_ADD)
            col = COLOR_ADD_NOT_SELECTED;
        else if(this->type == GEO_SUBTRACT)
            col = COLOR_SUB_NOT_SELECTED;
        else if(this->type == GEO_RED)
            col = COLOR_RED_NOT_SELECTED;
    }
    return col;
}
void geo_element::draw_geometry(video::IVideoDriver* driver, const video::SMaterial material)
{
    //driver->setTransform(video::ETS_WORLD, core::IdentityMatrix);
    //driver->setMaterial(material);
    //video::SColor col = video::SColor(255,38,128,1155);
    video::SColor col = video::SColor(255,38,128,155);

    for(int i =0; i<this->geometry.edges.size(); i++)
    {
        if(this->geometry.edges[i].topo_group != -1)
            driver->draw3DLine(this->geometry.getVertex(i,0).V,this->geometry.getVertex(i,1).V,col);
    }
}
polyfold* geometry_scene::get_total_geometry()
{
    return &this->total_geometry;
}

void geometry_scene::build_total_geometry()
{
    polyfold combo;

    for(int i=1; i<this->elements.size(); i++)
    {
        add_pfold(this->elements[i].geometry,combo);
    }
/*
    if(this->elements.size()>2)
    {
        combo.merge_faces();
        combo.simplify_edges();
        combo.reduce_edges_vertices2();
    }
*/

    std::cout<<"total geometry created "<<this->elements.size()<<" elements\n";

    this->total_geometry = combo;

    if(this->base_type == GEO_EMPTY)
        this->total_geometry.topology = TOP_CONVEX;
    else if(this->base_type == GEO_SOLID)
        this->total_geometry.topology = TOP_CONCAVE;
}

bool geo_element::has_geometry()
{
    //return true;
    return this->geometry.edges.size()>2;
}

void geometry_scene::add(polyfold pf)
{
    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_ADD;
    geo.brush.make_convex();
    this->elements.push_back(geo);
}
void geometry_scene::subtract(polyfold pf)
{
    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_SUBTRACT;
    geo.brush.make_concave();
    this->elements.push_back(geo);
}

void geometry_scene::set_type(int t)
{
    this->base_type=t;
}

void geometry_scene::generate_mesh()
{
    std::cout<<"generating mesh...\n";
    if(this->mesh_node)
        this->mesh_node->remove();

    scene::SMeshBuffer* buffer;
    scene::SMesh* mesh = new scene::SMesh;
    LineHolder nograph;

    polyfold pf = *this->get_total_geometry();

    //pf.merge_faces();
    //pf.simplify_edges();
    //pf.reduce_edges_vertices2();

    buffer = new scene::SMeshBuffer();
	buffer->Material.Lighting = false;
	buffer->Material.setTexture(0, driver->getTexture("wall.bmp"));
    for(int f_i =0 ;f_i<pf.faces.size(); f_i++)
    {
        buffer = new scene::SMeshBuffer();
        buffer->Material.Lighting = false;
        buffer->Material.setTexture(0, driver->getTexture("wall.bmp"));

        pf.trianglize(f_i,buffer,nograph,nograph);
        mesh->addMeshBuffer(buffer);
    }

    this->mesh_node = new scene::CMeshSceneNode(mesh,smgr->getRootSceneNode(),smgr,747);
    this->mesh_node->SetBox(pf.bbox);
    mesh->drop();

}

void geometry_scene::rebuild_geometry()
{
    LineHolder nograph;

    polyfold no_poly;

    for(int i=1; i<this->elements.size(); i++)
        this->elements[i].geometry = no_poly;

    for(int i=1; i<this->elements.size(); i++)
    {
        polyfold combo;
        int num=0;
        for(int j=1; j<i; j++)
        {
            if(this->elements[j].has_geometry() &&
               this->elements[i].brush.bbox.intersectsWithBox(this->elements[j].brush.bbox))
            {
                add_pfold(this->elements[j].geometry,combo);
                num++;
            }
        }
        std::cout<<"element "<<i<<" intersects "<<num<<" other elements\n";

        polyfold clipped_brush;

        //if(num>1)
        //    combo.merge_faces();

        if(this->base_type == GEO_EMPTY)
            combo.topology = TOP_CONVEX;
        else if(this->base_type == GEO_SOLID)
            combo.topology = TOP_CONCAVE;

        if(num >=0)
        {
            std::cout<<" clipping against combined poly with "<<combo.faces.size()<<" faces\n";

            if(this->elements[i].type == GEO_ADD)
            {
                clipped_brush = clip_poly2(this->elements[i].brush,combo,GEO_ADD,this->base_type,nograph);
            }
            else if(this->elements[i].type == GEO_SUBTRACT)
            {
                clipped_brush = clip_poly2(this->elements[i].brush,combo,GEO_SUBTRACT,this->base_type,nograph);
            }
        }
        else if ((this->elements[i].type==GEO_ADD && this->base_type == GEO_EMPTY) ||
                (this->elements[i].type==GEO_SUBTRACT && this->base_type == GEO_SOLID))
        {
            clipped_brush = this->elements[i].brush;
        }
        else
        {
            clipped_brush = no_poly;
        }

        this->elements[i].geometry = clipped_brush;

        for(int j=1; j<i; j++)
        {
            std::cout<<j<<":\n";
            if(this->elements[i].has_geometry() && this->elements[j].has_geometry() &&
               this->elements[i].brush.bbox.intersectsWithBox(this->elements[j].brush.bbox))
                {
                    if(this->elements[i].type == GEO_ADD)
                    {
                        this->elements[j].geometry = clip_poly3(this->elements[j].geometry,clipped_brush,GEO_ADD,this->base_type,nograph);
                    }
                    else if(this->elements[i].type == GEO_SUBTRACT)
                    {
                        this->elements[j].geometry = clip_poly3(this->elements[j].geometry,clipped_brush,GEO_SUBTRACT,this->base_type,nograph);
                    }

                    this->elements[j].geometry.reduce_edges_vertices2();
                }
        }

        this->elements[i].geometry.repair_clipped_poly();

        this->elements[i].geometry.finalize_clipped_poly();

/*
        std::cout<<"----\n";
        for(int f_i=0;f_i<this->elements[i].geometry.faces.size();f_i++)
        {
            std::cout<<"face "<<f_i<<": ";
            for(int ii = 0; ii< this->elements[i].geometry.faces[f_i].loops.size(); ii++)
            {
                if(this->elements[i].geometry.faces[f_i].loops[ii].type == LOOP_INNER)
                    std::cout<<this->elements[i].geometry.faces[f_i].loops[ii].vertices.size()<<" ";
                else
                    std::cout<<"("<<this->elements[i].geometry.faces[f_i].loops[ii].vertices.size()<<") ";
            }
            std::cout<<"\n";
        }*/
    }

    std::vector<geo_element> new_elements;
/*
    int removed=0;
    new_elements.push_back(this->elements[0]);

    for(int i=1; i<this->elements.size(); i++)
    {
        if(this->elements[i].has_geometry())
            new_elements.push_back(this->elements[i]);
        else
            removed++;
    }
    this->elements=new_elements;

    if(removed > 0)
        std::cout<<"removed "<<removed<<" elements\n";
*/
    this->build_total_geometry();

    this->generate_mesh();
}

void geometry_scene::copy_selection_to_active_brush()
{
    polyfold pf;

    for(int i=1; i<this->elements.size(); i++)
    {
        bool b=false;
        for(int j:this->selection)
            if(j==i)
                b=true;

        if(b)
            add_pfold(this->elements[i].geometry,pf);
    }

    pf.merge_faces();

    this->elements[0].brush = pf;
    this->elements[0].brush.topology = TOP_CONVEX;
}
void geometry_scene::delete_selection()
{
    std::vector<geo_element> new_elements;

    int removed=0;
    new_elements.push_back(this->elements[0]);
    for(int i=1; i<this->elements.size(); i++)
    {
        bool b=false;
        for(int j:this->selection)
            if(j==i)
                b=true;

        if(!b)
            new_elements.push_back(this->elements[i]);
        else
            removed++;
    }
    this->elements=new_elements;

    this->selection.clear();

    if(removed > 0)
    {
        std::cout<<"deleted "<<removed<<" elements\n";
    }
}


void add_pfold(polyfold pf,polyfold& ret)
{
    for(int f_i = 0; f_i <pf.faces.size(); f_i++)
    {
        poly_face f;

        f.m_normal = pf.faces[f_i].m_normal;
        f.bFlippedNormal = pf.faces[f_i].bFlippedNormal;
        f.m_center = pf.faces[f_i].m_center;

        for(poly_loop loop : pf.faces[f_i].loops)
        {
            poly_loop new_loop;
            for(int v_i : loop.vertices)
            {
                int v = ret.get_point_or_add(pf.vertices[v_i].V);
                new_loop.vertices.push_back(v);
                f.addVertex(v);
            }

            std::vector<int> tempv = loop.vertices;
            tempv.push_back(tempv[0]);

            for(int i=0; i < tempv.size()-1; i++)
               {
                core::vector3df v0=pf.vertices[tempv[i]].V;
                core::vector3df v1=pf.vertices[tempv[i+1]].V;
                int new_e = ret.get_edge_or_add(ret.get_point_or_add(v0),ret.get_point_or_add(v1),0);
                f.addEdge(new_e);
               }

            new_loop.type = loop.type;
            new_loop.topo_group = loop.topo_group;
            ret.calc_loop_bbox(f,new_loop);
            f.loops.push_back(new_loop);
        }

        ret.faces.push_back(f);
    }

    //ret.merge_faces();

    //std::cout<<"... done with merge\n";

    ret.bbox.addInternalBox(pf.bbox);
}

void polyfold::merge_loops()
{/*
    for(int f_i = 0; f_i <this->faces.size()-1; f_i++)
    {
        for(int p_i=0; p_i<this->faces[f_i].loops.size(); p_i++)
            for(int p_j=0; p_j<p_i; p_j++)
            {
                poly_loop new_loop;
                for(int v_i : this->faces[f_i].loops[p_i].vertices)
                {
                    int v = ret.get_point_or_add(pf.vertices[v_i].V);
                    new_loop.vertices.push_back(v);
                    f.addVertex(v);
                }

                std::vector<int> tempv = loop.vertices;
                tempv.push_back(tempv[0]);

                for(int i=0; i < tempv.size()-1; i++)
                   {



                   }
            }
    }*/
}
void polyfold::merge_faces2()
{
    int n_faces = this->faces.size();
    for(int f_i = 0; f_i <this->faces.size()-1; f_i++)
        for(int f_j = f_i+1; f_j <this->faces.size(); f_j++)
    {
        if(is_parallel_normal(this->faces[f_i].m_normal,this->faces[f_j].m_normal) && this->faces[f_i].m_normal.dotProduct(this->faces[f_j].m_normal) > 0)
        {

            for(int p_j=0; p_j< this->faces[f_j].loops.size(); p_j++ )
                this->faces[f_i].loops.push_back(this->faces[f_j].loops[p_j]);

            this->faces[f_j].loops.clear();
        }
    }

    std::vector<poly_face> new_faces;
    for(int f_i = 0; f_i <this->faces.size(); f_i++)
    {
        if(this->faces[f_i].loops.size()>0)
            new_faces.push_back(this->faces[f_i]);
    }
    this->faces = new_faces;

    int n_faces_merged = n_faces - this->faces.size();

    if(n_faces_merged>0) std::cout<<" merged "<<n_faces_merged<<" faces\n";
   // std::cout<<"ok..\n";
   // this->reduce_edges_vertices2();
   // this->simplify_edges();
    this->recalc_bbox_and_loops();
    this->reduce_edges_vertices2();
}


void polyfold::merge_faces()
{
    int n_faces_merged=0;
    try_again_merge_faces:
    for(int f_i = 0; f_i <this->faces.size()-1; f_i++)
        for(int f_j = f_i+1; f_j <this->faces.size(); f_j++)
    {
        if(this->faces[f_i].m_normal.dotProduct(this->faces[f_j].m_normal) > 0.999)
        {
            bool bMerge = false;
            for(int e_i: this->faces[f_i].edges)
                 for(int e_j: this->faces[f_j].edges)
            {
                if(e_i == e_j)
                {
                    this->edges[e_i].topo_group = -1;
                    bMerge=true;
                }
            }
            if(bMerge)
            {
                //std::cout<<"Merging faces "<<f_i<<" and "<<f_j<<"\n";
                n_faces_merged++;

                for(int e_j : this->faces[f_j].edges)
                    this->faces[f_i].addEdge(e_j);

                for(int v_j : this->faces[f_j].vertices)
                    this->faces[f_i].addVertex(v_j);
/*
                this->faces[f_i].loops.clear();
                LineHolder nograph;
                this->calc_loops4(f_i,nograph);

                for(poly_loop &loop : this->faces[f_i].loops)
                    this->set_loop_solid(this->faces[f_i],loop);
                this->sort_loops(this->faces[f_i]);
*/
                std::vector<poly_face> fvec;
                for(int f_k = 0; f_k<this->faces.size(); f_k++)
                {
                    if(f_k != f_j)
                        fvec.push_back(this->faces[f_k]);
                }
                this->faces = fvec;
                goto try_again_merge_faces;
            }
        }
    }
    if(n_faces_merged>0) std::cout<<" merged "<<n_faces_merged<<" faces\n";
   // std::cout<<"ok..\n";
   // this->reduce_edges_vertices2();
   // this->simplify_edges();
    this->recalc_bbox_and_loops();
    this->reduce_edges_vertices2();

}


//=======================================================================================================

bool vec_is_left_from(core::vector3df v0_, core::vector3df v1_)
{
    core::vector3df v0=v0_;
    core::vector3df v1=v1_;
    v0.normalize();
    v1.normalize();
    return (v0.crossProduct(v1).Y > 0.001);
}

bool vec_is_right_from(core::vector3df v0_, core::vector3df v1_)
{
    core::vector3df v0=v0_;
    core::vector3df v1=v1_;
    v0.normalize();
    v1.normalize();

    return (v0.crossProduct(v1).Y < -0.001);
}

bool line_intersects_line(core::line2df line_1, core::line2df line_2, core::vector2df& outvec)
{
    if(line_1.intersectWith(line_2,outvec))
        return true;
    else
    {
        core::vector2df r1 = line_1.getClosestPoint(line_2.start)-line_2.start;
        core::vector2df r2 = line_1.getClosestPoint(line_2.end)-line_2.end;

        if(r1.getLength()<0.1)
        {
            outvec = line_2.start;
            return true;
        }
        else if( r2.getLength()<0.1)
        {
            outvec = line_2.end;
            return true;
        }
    }
    return false;
}

int polyfold::get_edge_loop_no(int f_i, int e_i)
{
    int v_0 = this->edges[e_i].v0;
    int v_1 = this->edges[e_i].v1;

    for(int p_i = 0 ; p_i < this->faces[f_i].loops.size(); p_i ++)
        for(int v_i : this->faces[f_i].loops[p_i].vertices)
            if(v_i == v_0 || v_i == v_1)
                return p_i;
    return -1;
}

std::vector<int> polyfold::get_vert_loop_no(int f_i, int my_v)
{
    std::vector<int> ret;
    for(int p_i = 0 ; p_i < this->faces[f_i].loops.size(); p_i ++)
        for(int v_i : this->faces[f_i].loops[p_i].vertices)
            if(v_i == my_v)
                ret.push_back(p_i);
    return ret;
}

bool polyfold::get_facial_point(int face_i, int edge_i, int loop_i, core::vector3df & out, LineHolder &graph)
{
    int ev_0 = this->edges[edge_i].v0;
    int ev_1 = this->edges[edge_i].v1;

    int v_0=-1;
    int v_1=-1;
    int n = this->faces[face_i].loops[loop_i].vertices.size()-1;

    if(this->faces[face_i].loops[loop_i].vertices[0] == ev_0 && this->faces[face_i].loops[loop_i].vertices[n] == ev_1)
    {
     v_0 = ev_1;
     v_1 = ev_0;
    }
    else if(this->faces[face_i].loops[loop_i].vertices[0] == ev_1 && this->faces[face_i].loops[loop_i].vertices[n] == ev_0)
    {
     v_0 = ev_0;
     v_1 = ev_1;
    }
    else
        for(int i=0; i<n; i++)
        {
            if(this->faces[face_i].loops[loop_i].vertices[i] == ev_0 && this->faces[face_i].loops[loop_i].vertices[i+1] == ev_1)
            {
                v_0 = ev_0;
                v_1 = ev_1;
            }
            else if(this->faces[face_i].loops[loop_i].vertices[i] == ev_1 && this->faces[face_i].loops[loop_i].vertices[i+1] == ev_0)
            {
                v_0 = ev_1;
                v_1 = ev_0;
            }
        }

    if(v_0==-1)
    {
        std::cout<<"*error* get_facial_point, could not find edge on loop\n";
        return false;
    }

    core::vector3df v0 = this->vertices[v_0].V;
    core::vector3df v1 = this->vertices[v_1].V;

    core::vector3df r = v1-v0;

    core::vector3df v3 = r.crossProduct(this->faces[face_i].getOrientingNormal());
    v3.normalize();

    core::vector3df ret = v0+ (v1-v0)*0.5 - v3;

    graph.points.push_back(ret);
    graph.lines.push_back(core::line3df(this->vertices[v_0].V,this->vertices[v_1].V));

    out = ret;
    return true;
}
/*
bool polyfold::get_facial_point(int face_i, int edge_i, int loop_i, core::vector3df & ret, LineHolder &graph)
{
    core::matrix4 R = this->faces[face_i].get2Dmat();

    polyfold pf;
    poly_face f;

    std::cout<<"face: "<<face_i<<" "<<"edge: "<<edge_i<<"\n";

   for(int v_i : this->faces[face_i].vertices)
    {
        core::vector3df r = this->vertices[v_i].V;
        R.rotateVect(r);
        int new_v = pf.get_point_or_add(r);
        f.addVertex(new_v);
        //graph.points.push_back(r);
    }

    poly_loop loop;
    for(int v_i : this->faces[face_i].loops[loop_i].vertices)
    {
        core::vector3df r = this->vertices[v_i].V;
        R.rotateVect(r);
        //graph.points.push_back(r);
        int new_v = pf.get_point_or_add(r);
        f.addVertex(new_v);
        loop.vertices.push_back(new_v);
    }

    if(loop.vertices.size() >0)
        f.loops.push_back(loop);
    else return false;



    std::vector<int> edges_i = this->get_all_loop_edges(face_i,loop_i);

    for(int e_i : edges_i)
    {
        if(this->edges[e_i].topo_group == -1)
            continue;

        core::vector3df v0 = this->getVertex(e_i,0).V;
        core::vector3df v1 = this->getVertex(e_i,1).V;
        R.rotateVect(v0);
        R.rotateVect(v1);
        int v_0 = pf.find_point(v0);
        int v_1 = pf.find_point(v1);
        int new_e = pf.get_edge_or_add(v_0,v_1,0);
        f.addEdge(new_e);
        graph.lines.push_back(core::line3df(v0,v1));
    }

    //graph.lines.push_back(core::line3df(this->getVertex(edge_i,0).V,this->getVertex(edge_i,1).V));


    pf.faces.push_back(f);

    core::vector3df ev0 = this->getVertex(edge_i,0).V;
    core::vector3df ev1 = this->getVertex(edge_i,1).V;
    R.rotateVect(ev0);
    R.rotateVect(ev1);

    int my_edge = pf.find_edge(ev0,ev1);

    if(my_edge == -1)
    {
        std::cout<<"Edge not on face: Error\n";
        return false;
    }

    //std::cout<<loop_i<<", "<<f.loops.size()<<" ...\n";
    //std::cout<<"searching "<<pf.edges[my_edge].v0<<","<<pf.edges[my_edge].v1<<"\n";
    {

        std::vector<int> v_list;
        v_list.push_back(f.loops[0].vertices[f.loops[0].vertices.size()-1]);
        //std::cout<<"0\n";

        for(int v_i : f.loops[0].vertices)
        {
            v_list.push_back(v_i);
        }
        v_list.push_back(v_list[1]);

       // for(int i : v_list)
       //     std::cout<<i<<" ";
       // std::cout<<" ("<<pf.edges[my_edge].v0<<","<<pf.edges[my_edge].v1<<")\n";
       // std::cout<<"\n";


        std::vector<int> edge_ends;

       // for(int i=1; i< v_list.size()-1; i++)
       // {
       //     if(v_list[i] == pf.edges[my_edge].v0)
       //         edge_ends.push_back(i);
       //     else if(v_list[i] == pf.edges[my_edge].v1)
       //         edge_ends.push_back(i);

       //     //if(v_list[i] == pf.edges[my_edge].v1)
       // }

        int end_n = v_list.size()-2;

        if((pf.edges[my_edge].v0 == v_list[1] && pf.edges[my_edge].v1 == v_list[end_n]) ||
           (pf.edges[my_edge].v1 == v_list[1] && pf.edges[my_edge].v0 == v_list[end_n]))
           {
            //std::cout<<"YES!\n";
            edge_ends.push_back(1);
            edge_ends.push_back(end_n);
           }
        else
            for(int i=1; i< v_list.size()-1; i++)
            {
                if(v_list[i] == pf.edges[my_edge].v0 && v_list[i+1] == pf.edges[my_edge].v1)
                {
                    edge_ends.push_back(i);
                    edge_ends.push_back(i+1);
                }
                else if(v_list[i] == pf.edges[my_edge].v0 && v_list[i-1] == pf.edges[my_edge].v1)
                {
                    edge_ends.push_back(i-1);
                    edge_ends.push_back(i);
                }

            }

       // std::cout<<"--> "<<edge_ends[0]<<","<<edge_ends[1]<<"\n";

        if(edge_ends.size() != 2)
        {
            std::cout<<"*warning* edge not found in v_list\n";
            return false;
        }



        std::vector<int> res[2];

        res[0].push_back(v_list[edge_ends[0]-1]);
        res[1].push_back(v_list[edge_ends[1]+1]);

        res[0].push_back(v_list[edge_ends[0]+1]);
        res[1].push_back(v_list[edge_ends[1]-1]);

        for(int j=0; j<2; j++ )
        {
            int my_v = edge_ends[j];
            for(int i=0; i<f.vertices.size(); i++)
            {
                core::vector3df v0      = pf.vertices[v_list[my_v]].V;
                core::vector3df v1      = pf.vertices[i].V;
                core::vector3df v_left  = pf.vertices[v_list[my_v+1]].V;
                core::vector3df v_right = pf.vertices[v_list[my_v-1]].V;

                core::vector3df r = v1 - v0;
                core::vector3df left_r = v_left - v0;
                core::vector3df right_r = v_right - v0;

               // std::vector<int> edges0 = pf.get_edges_from_point(0,v_list[my_v]);
               // std::vector<int> edges1 = pf.get_edges_from_point(0,i);

               // std::cout<<j<<": \n";
               // for(int i : edges0)
               //     std::cout<<i<<" ";
               // std::cout<<"...."
               // for(int i : edges1)
               //     std::cout<<i<<" ";
               // std::cout<<"\n";

                if(vec_is_left_from(- left_r, right_r))
                    {
                        if(vec_is_left_from(r,right_r) || vec_is_right_from(r,left_r))
                        {

                            core::line2df line_1 = core::line2df(v0.X,v0.Z,v1.X,v1.Z);

                            bool b=false;

                            //graph.lines.push_back(core::line3df(v0,v1));

                            for(int e_i=0; e_i <pf.edges.size();e_i++)
                            {
                                core::vector2df ipoint;
                                core::line2df line_2 = core::line2df(pf.getVertex(e_i,0).V.X,pf.getVertex(e_i,0).V.Z,pf.getVertex(e_i,1).V.X,pf.getVertex(e_i,1).V.Z);
                                if(line_intersects_line(line_1,line_2,ipoint))
                                  {
                                    if(!is_same_point(line_1.start,ipoint) && !is_same_point(line_1.end,ipoint))
                                        b=true;
                                  }
                            }
                            if(!b)
                                {
                                graph.lines.push_back(core::line3df(v0,v1));
                                res[j].push_back(i);
                                }
                        }
                    }
                else
                        if (vec_is_left_from(r,right_r) && vec_is_right_from(r,left_r))
                        {
                            //graph.lines.push_back(core::line3df(v0,v1));

                            core::line2df line_1 = core::line2df(v0.X,v0.Z,v1.X,v1.Z);

                            bool b=false;

                            for(int e_i=0; e_i< pf.edges.size();e_i++)
                            {
                                core::vector2df ipoint;
                                core::line2df line_2 = core::line2df(pf.getVertex(e_i,0).V.X,pf.getVertex(e_i,0).V.Z,pf.getVertex(e_i,1).V.X,pf.getVertex(e_i,1).V.Z);

                                if(line_intersects_line(line_1,line_2,ipoint))
                                  {
                                    if(!is_same_point(line_1.start,ipoint) && !is_same_point(line_1.end,ipoint))
                                        b=true;
                                  }
                            }
                            if(!b)
                                {
                                res[j].push_back(i);
                                graph.lines.push_back(core::line3df(v0,v1));
                                }
                        }
            }
        }//for j

        core::matrix4 R_inv = R;
        R_inv.makeInverse();

        int cc=0;
        for(int v_i : res[0])
            for(int v_j : res[1])
            {
                if(v_i == v_j)
                {
                    cc++;
                }
            }

        for(int v_i : res[0])
            for(int v_j : res[1])
            {
                if(v_i == v_j)
                {
                core::vector3df v2 = pf.vertices[v_i].V;
                core::vector3df v0 = pf.getVertex(my_edge,0).V;
                core::vector3df v1 = pf.getVertex(my_edge,1).V;

                core::vector3df w0 = v2-v1;
                core::vector3df w1 = v2-v0;
                w0.normalize();
                w1.normalize();
                if(is_parallel_normal(w0,w1)==false)
                {
                    R_inv.rotateVect(v2);
                    R_inv.rotateVect(v0);
                    R_inv.rotateVect(v1);

                    graph.points.push_back(v1);
                    graph.points.push_back(v0);
                    graph.lines.push_back(core::line3df(v0,v2));
                    graph.lines.push_back(core::line3df(v1,v2));

                    //ret.X = (v0.X + v1.X + v2.X)/3.0;
                    //ret.Y = (v0.Y + v1.Y + v2.Y)/3.0;
                    //ret.Z = (v0.Z + v1.Z + v2.Z)/3.0;
                    core::vector3df v3 = core::vector3df(v0+(v1-v0)*0.5);
                    ret = v3 + (v2-v3)*0.05;

                    //std::cout<<ret.X<<","<<ret.Y<<","<<ret.Z<<"\n";
                    return true;
                }
                }
            }
    }
    std::cout<<"*ERROR could not find any point on face "<<face_i<<" for edge "<<edge_i<<", loop "<<loop_i<<" *\n";
    return false;
}
*/

std::vector<int> polyfold::get_all_loop_edges(int f_i, int p_i)
{
    std::vector<int> v_list;
    v_list.push_back(this->faces[f_i].loops[p_i].vertices[this->faces[f_i].loops[p_i].vertices.size()-1]);
    for(int v_i : this->faces[f_i].loops[p_i].vertices)
    {
        v_list.push_back(v_i);
    }
    std::vector<int> ret;
    for(int i=0;i<v_list.size()-1;i++)
    {
        int e = this->find_edge(v_list[i],v_list[i+1]);
        if(e != -1)
            ret.push_back(e);
    }
    return ret;
}

void polyfold::classify_edges(LineHolder& graph)
{
    for(poly_edge& edge : this->edges)
    {
        edge.conv = TOP_UNDEF;
    }

    for(int f_i=0;f_i<this->faces.size();f_i++)
    {
       // std::cout<<f_i<<"\n";
        for(int p_i=0; p_i < this->faces[f_i].loops.size(); p_i++)
        {
            std::vector<int> edges_i = this->get_all_loop_edges(f_i,p_i);
            //for(int e_i: edges_i)
            //     std::cout<<e_i<<" ";
            //std::cout<<"\n";
            for(int f_j=f_i+1;f_j<this->faces.size();f_j++)
            {
                for(int p_j=0; p_j < this->faces[f_j].loops.size(); p_j++)
                {
                    std::vector<int> edges_j = this->get_all_loop_edges(f_j,p_j);
                    std::vector<int> common_edges;
                    for(int e_i: edges_i)
                        for(int e_j: edges_j)
                    {
                        if(e_i==e_j)
                        {
                            common_edges.push_back(e_i);
                           // std::cout<<e_i<<" ";
                        }
                    }
                    for(int e_i : common_edges)
                    {
                        //if(!(f_i == 3 && e_i == 21)) continue;

                        core::vector3df cp = this->faces[f_i].m_normal.crossProduct(this->faces[f_j].m_normal);
                        core::matrix4 R;
                        cp.normalize();
                        R.buildRotateFromTo(cp,core::vector3df(0,1,0));

                        core::vector3df m1;
                        core::vector3df m2;
                        core::vector3df r1;
                        core::vector3df r2;

                        LineHolder nograph;

                        R.rotateVect(m1, this->faces[f_i].m_normal);
                        R.rotateVect(m2, this->faces[f_j].m_normal);
                        //R.rotateVect(r1, this->faces[sides[0]].m_center);
                        //R.rotateVect(r2, this->faces[sides[1]].m_center);

                        bool bOk = this->get_facial_point(f_i,e_i,p_i,r1,graph);
                        if(!bOk) continue;

                        bOk = this->get_facial_point(f_j,e_i,p_j,r2,graph);
                        if(!bOk) continue;

                        R.rotateVect(r1);
                        R.rotateVect(r2);
                        m1.normalize();
                        m2.normalize();

                        //m1*=25;
                        //m2*=25;

                        //std::cout<<r1.X<<","<<r1.Z<<"\n";
                        //std::cout<<r2.X<<","<<r2.Z<<"\n";

                        //graph.points.push_back(core::vector3df(r1.X,0,r1.Z));
                        //graph.points.push_back(core::vector3df(r2.X,0,r2.Z));

                        core::line2df line1 = core::line2df(r1.X,r1.Z,r1.X+m1.X,r1.Z+m1.Z);
                        core::line2df line2 = core::line2df(r2.X,r2.Z,r2.X+m2.X,r2.Z+m2.Z);

                        core::vector2df ipoint;

                        if(line1.intersectWith(line2,ipoint,false))
                        {
                            if(   core::vector2df(m1.X,m1.Z).dotProduct(ipoint-core::vector2df(r1.X,r1.Z)) < 0
                               && core::vector2df(m2.X,m2.Z).dotProduct(ipoint-core::vector2df(r2.X,r2.Z)) < 0)
                                this->edges[e_i].conv = TOP_CONVEX;
                            else
                                this->edges[e_i].conv = TOP_CONCAVE;
                        }
                    }
                }
            }
        }
    }
}



int polyfold::classify_edge(int edge)
{
    return this->edges[edge].conv;
}


//=======================================================================================================


