
#include <irrlicht.h>
#include <iostream>
#include "csg_classes.h"
#include "edit_env.h"
#include "tolerances.h"

using namespace irr;

void add_pfold(polyfold pf,polyfold& ret)
{
    int n_surface_groups=ret.surface_groups.size();

    for(int i=0;i<pf.surface_groups.size();i++)
        ret.surface_groups.push_back(pf.surface_groups[i]);

    for(int f_i = 0; f_i <pf.faces.size(); f_i++)
    {
        poly_face f;

        f.m_normal = pf.faces[f_i].m_normal;
        f.bFlippedNormal = pf.faces[f_i].bFlippedNormal;
        f.m_center = pf.faces[f_i].m_center;
        f.texture_name = pf.faces[f_i].texture_name;
        f.original_brush = pf.faces[f_i].original_brush;
        f.original_face = pf.faces[f_i].original_face;
        f.surface_group = pf.faces[f_i].surface_group+n_surface_groups;
        f.material_group = pf.faces[f_i].material_group;
        f.uv_origin = pf.faces[f_i].uv_origin;
        f.uv_mat = pf.faces[f_i].uv_mat;

        for(poly_loop loop : pf.faces[f_i].loops)
        {
            poly_loop new_loop;
            for(int v_i : loop.vertices)
            {
                int v = ret.get_point_or_add(pf.vertices[v_i].V);
                new_loop.vertices.push_back(v);
                f.addVertex(v);
            }

            std::vector<int> tempv = loop.vertices;
            tempv.push_back(tempv[0]);

            for(int i=0; i < tempv.size()-1; i++)
               {
                core::vector3df v0=pf.vertices[tempv[i]].V;
                core::vector3df v1=pf.vertices[tempv[i+1]].V;
                int new_e = ret.get_edge_or_add(ret.get_point_or_add(v0),ret.get_point_or_add(v1),0);
                f.addEdge(new_e);
               }

            new_loop.type = loop.type;
            new_loop.topo_group = loop.topo_group;
            ret.calc_loop_bbox(f,new_loop);
            f.loops.push_back(new_loop);
        }

        ret.faces.push_back(f);
    }

    ret.bbox.addInternalBox(pf.bbox);
}

void polyfold::merge_faces2()
{

    int n_faces = this->faces.size();

    if(n_faces == 0)
        return;

    for(int f_i = 0; f_i <this->faces.size()-1; f_i++)
        for(int f_j = f_i+1; f_j <this->faces.size(); f_j++)
    {

        core::plane3df f_plane = core::plane3df(this->faces[f_i].m_center,this->faces[f_i].m_normal);

        if(is_parallel_normal(this->faces[f_i].m_normal,this->faces[f_j].m_normal)
           && this->faces[f_i].m_normal.dotProduct(this->faces[f_j].m_normal) > 0
           && is_coplanar_point(f_plane,this->faces[f_j].m_center))
        {
            for(int p_j=0; p_j< this->faces[f_j].loops.size(); p_j++ )
                this->faces[f_i].loops.push_back(this->faces[f_j].loops[p_j]);

            this->faces[f_j].loops.clear();
        }
    }

    std::vector<poly_face> new_faces;
    for(int f_i = 0; f_i <this->faces.size(); f_i++)
    {
        if(this->faces[f_i].loops.size()>0)
            new_faces.push_back(this->faces[f_i]);
    }
    this->faces = new_faces;

    int n_faces_merged = n_faces - this->faces.size();

    if(n_faces_merged>0) std::cout<<" merged "<<n_faces_merged<<" faces\n";


    polyfold positive;
    polyfold negative;

    negative.vertices = this->vertices;
    positive.vertices = this->vertices;

    for(int f_i=0;f_i<faces.size();f_i++)
    {
        poly_face f;
        poly_face f_p;

        f.m_center          = faces[f_i].m_center;
        f.m_normal          = faces[f_i].m_normal;
        f.bFlippedNormal    = faces[f_i].bFlippedNormal;

        f_p.m_center        = faces[f_i].m_center;
        f_p.m_normal        = faces[f_i].m_normal;
        f_p.bFlippedNormal  = faces[f_i].bFlippedNormal;

        for(int p=0;p<faces[f_i].loops.size();p++)
        {
            if(faces[f_i].loops[p].topo_group == LOOP_HOLLOW)
                {
                    f.loops.push_back(faces[f_i].loops[p]);
                    faces[f_i].loops[p].vertices.clear();
                }
        }
        negative.faces.push_back(f);

        for(int p=0;p<faces[f_i].loops.size();p++)
        {
            if(faces[f_i].loops[p].topo_group == LOOP_SOLID)
                {
                    f_p.loops.push_back(faces[f_i].loops[p]);
                    faces[f_i].loops[p].vertices.clear();
                }
        }
        positive.faces.push_back(f_p);
    }

    negative.reduce_edges_vertices2();
    positive.reduce_edges_vertices2();

    for(int f_i=0;f_i<faces.size();f_i++)
    {
        positive.meld_loops(f_i,false);
    }

    for(int f_i=0;f_i<faces.size();f_i++)
    {
       // negative.meld_loops(f_i);
    }

    for(int f_i=0;f_i<faces.size();f_i++)
    {
        for(int p=0;p<negative.faces[f_i].loops.size();p++)
        {
            poly_loop loop;
            for(int v_i=0;v_i<negative.faces[f_i].loops[p].vertices.size();v_i++)
            {
                core::vector3df V = negative.vertices[negative.faces[f_i].loops[p].vertices[v_i]].V;
                int v = this->get_point_or_add(V);
                loop.vertices.push_back(v);
            }
            loop.topo_group=LOOP_HOLLOW;

            //this->calc_loop_bbox(positive.faces[f_i],loop);
            this->faces[f_i].loops.push_back(loop);
        }

        for(int p=0;p<positive.faces[f_i].loops.size();p++)
        {
            poly_loop loop;
            for(int v_i=0;v_i<positive.faces[f_i].loops[p].vertices.size();v_i++)
            {
                core::vector3df V = positive.vertices[positive.faces[f_i].loops[p].vertices[v_i]].V;
                int v = this->get_point_or_add(V);
                loop.vertices.push_back(v);
            }
            if(positive.faces[f_i].loops[p].type == LOOP_INNER)
                loop.topo_group=LOOP_SOLID;
            else
                loop.topo_group=LOOP_HOLLOW;

            //this->calc_loop_bbox(positive.faces[f_i],loop);
            this->faces[f_i].loops.push_back(loop);

        }
    }
    for(int f_i=0;f_i<faces.size();f_i++)
    {
        for(int p=0;p<faces[f_i].loops.size();p++)
        {
            if(faces[f_i].loops[p].topo_group == LOOP_SOLID)
                this->set_loop_solid(f_i,p);
            else
                this->set_loop_open(f_i,p);
        }
    }

    reduce_edges_vertices2();

    this->recalc_bbox();
}


//=======================================================================================================

bool vec_is_left_from(core::vector3df v0_, core::vector3df v1_)
{
    core::vector3df v0=v0_;
    core::vector3df v1=v1_;
    v0.normalize();
    v1.normalize();
    return (v0.crossProduct(v1).Y > 0.001);
}

bool vec_is_right_from(core::vector3df v0_, core::vector3df v1_)
{
    core::vector3df v0=v0_;
    core::vector3df v1=v1_;
    v0.normalize();
    v1.normalize();

    return (v0.crossProduct(v1).Y < -0.001);
}

bool line_intersects_line(core::line2df line_1, core::line2df line_2, core::vector2df& outvec)
{
    if(line_1.intersectWith(line_2,outvec))
        return true;
    else
    {
        core::vector2df r1 = line_1.getClosestPoint(line_2.start)-line_2.start;
        core::vector2df r2 = line_1.getClosestPoint(line_2.end)-line_2.end;

        if(r1.getLength()<0.1)
        {
            outvec = line_2.start;
            return true;
        }
        else if( r2.getLength()<0.1)
        {
            outvec = line_2.end;
            return true;
        }
    }
    return false;
}

int polyfold::get_edge_loop_no(int f_i, int e_i)
{
    int v_0 = this->edges[e_i].v0;
    int v_1 = this->edges[e_i].v1;

    for(int p_i = 0 ; p_i < this->faces[f_i].loops.size(); p_i ++)
        for(int v_i : this->faces[f_i].loops[p_i].vertices)
            if(v_i == v_0 || v_i == v_1)
                return p_i;
    return -1;
}

std::vector<int> polyfold::get_vert_loop_no(int f_i, int my_v)
{
    std::vector<int> ret;
    for(int p_i = 0 ; p_i < this->faces[f_i].loops.size(); p_i ++)
        for(int v_i : this->faces[f_i].loops[p_i].vertices)
            if(v_i == my_v)
                ret.push_back(p_i);
    return ret;
}

//This function is known to fail in some cases XD (tiny slivers)
bool polyfold::get_facial_point(int face_i, int edge_i, int loop_i, core::vector3df & out, LineHolder &graph)
{
    int ev_0 = this->edges[edge_i].v0;
    int ev_1 = this->edges[edge_i].v1;

    int v_0=-1;
    int v_1=-1;
    int n = this->faces[face_i].loops[loop_i].vertices.size()-1;

    if(this->faces[face_i].loops[loop_i].vertices[0] == ev_0 && this->faces[face_i].loops[loop_i].vertices[n] == ev_1)
    {
     v_0 = ev_1;
     v_1 = ev_0;
    }
    else if(this->faces[face_i].loops[loop_i].vertices[0] == ev_1 && this->faces[face_i].loops[loop_i].vertices[n] == ev_0)
    {
     v_0 = ev_0;
     v_1 = ev_1;
    }
    else
        for(int i=0; i<n; i++)
        {
            if(this->faces[face_i].loops[loop_i].vertices[i] == ev_0 && this->faces[face_i].loops[loop_i].vertices[i+1] == ev_1)
            {
                v_0 = ev_0;
                v_1 = ev_1;
            }
            else if(this->faces[face_i].loops[loop_i].vertices[i] == ev_1 && this->faces[face_i].loops[loop_i].vertices[i+1] == ev_0)
            {
                v_0 = ev_1;
                v_1 = ev_0;
            }
        }

    if(v_0==-1)
    {
        std::cout<<"*error* get_facial_point, could not find edge on loop\n";
        return false;
    }

    core::vector3df v0 = this->vertices[v_0].V;
    core::vector3df v1 = this->vertices[v_1].V;

    core::vector3df r = v1-v0;

    core::vector3df v3 = r.crossProduct(this->faces[face_i].getOrientingNormal());
    v3.normalize();
    v3*=0.25;

    core::vector3df ret = v0+ (v1-v0)*0.5 - v3;

    graph.points.push_back(ret);
    graph.lines.push_back(core::line3df(this->vertices[v_0].V,this->vertices[v_1].V));

    out = ret;
    return true;
}

std::vector<int> polyfold::get_all_loop_edges(int f_i, int p_i)
{
    std::vector<int> v_list;
    v_list.push_back(this->faces[f_i].loops[p_i].vertices[this->faces[f_i].loops[p_i].vertices.size()-1]);
    for(int v_i : this->faces[f_i].loops[p_i].vertices)
    {
        v_list.push_back(v_i);
    }
    std::vector<int> ret;
    for(int i=0;i<v_list.size()-1;i++)
    {
        int e = this->find_edge(v_list[i],v_list[i+1]);
        if(e != -1)
            ret.push_back(e);
    }
    return ret;
}

void polyfold::classify_edges(LineHolder& graph)
{
    for(poly_edge& edge : this->edges)
    {
        edge.conv = EDGE_UNDEF;
    }

    for(int e_0=0; e_0<this->edges.size(); e_0++)
    {
        std::vector<int> nfaces;
        for(int f_i=0;f_i<this->faces.size();f_i++)
        {
            for(int e_i : this->faces[f_i].edges)
            {
                if(e_i == e_0)
                    nfaces.push_back(f_i);
            }
        }

        if(nfaces.size() == 1)
        {
            this->edges[e_0].conv = EDGE_SIMPLE;
            continue;
        }
        else if(nfaces.size() > 2)
        {
            this->edges[e_0].conv = EDGE_COMPLEX;
            continue;
        }
        else if(nfaces.size()==0)
            continue;

        std::vector<core::vector3df> face_vecs;

        core::vector3df v1 = this->getVertex(e_0,0).V - this->getVertex(e_0,1).V;

        for(int f_i : nfaces)
        {
            core::vector3df r = v1.crossProduct(this->faces[f_i].m_normal);
            r.normalize();
            //r*=2;
            if(this->is_point_on_face(f_i,this->getVertex(e_0,1).V+v1*0.5+r))
                face_vecs.push_back(r);
            else
                face_vecs.push_back(-r);
        }

        core::matrix4 R;
        v1.normalize();
        R.buildRotateFromTo(v1,core::vector3df(0,1,0));

        core::vector3df m1;
        core::vector3df m2;
        core::vector3df r1 = this->getVertex(e_0,1).V+v1*0.5+face_vecs[0];
        core::vector3df r2 = this->getVertex(e_0,1).V+v1*0.5+face_vecs[1];

        LineHolder nograph;

        R.rotateVect(m1, this->faces[nfaces[0]].m_normal);
        R.rotateVect(m2, this->faces[nfaces[1]].m_normal);

        R.rotateVect(r1);
        R.rotateVect(r2);
        m1.normalize();
        m2.normalize();

        //graph.points.push_back(core::vector3df(r1.X,0,r1.Z));
        //graph.points.push_back(core::vector3df(r2.X,0,r2.Z));

        core::line2df line1 = core::line2df(r1.X,r1.Z,r1.X+m1.X,r1.Z+m1.Z);
        core::line2df line2 = core::line2df(r2.X,r2.Z,r2.X+m2.X,r2.Z+m2.Z);

        core::vector2df ipoint;

        if(line1.intersectWith(line2,ipoint,false))
        {
            if(   core::vector2df(m1.X,m1.Z).dotProduct(ipoint-core::vector2df(r1.X,r1.Z)) < 0
               && core::vector2df(m2.X,m2.Z).dotProduct(ipoint-core::vector2df(r2.X,r2.Z)) < 0)
            {
                this->edges[e_0].conv = EDGE_CONVEX;
            }
            else
            {
                this->edges[e_0].conv = EDGE_CONCAVE;
            }
        }
    }
}

int polyfold::classify_edge(int edge)
{
    return this->edges[edge].conv;
}


//=======================================================================================================


