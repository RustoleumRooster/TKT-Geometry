
#include <irrlicht.h>
#include <iostream>
#include "csg_classes.h"
#include "tolerances.h"

using namespace irr;

#define LOOP_BBOX_SMALL_NUMBER 0.01
#define LEFT_RIGHT_TEST_SMALL_NUMBER 0.005
#define LEFT_RIGHT_TEST_INCLUDE_NUMBER 0.01
#define POINT_IS_COPLANAR_DIST 0.01
#define POINT_IS_COLINEAR_DIST 0.01
#define LINE_IS_COPLANAR_DOT 0.001
#define PLANE_IS_COPLANAR_DOT 0.9999
#define BOX_INTERSECT_TOLERANCE 0.1

bool is_same_point(core::vector3df v0, core::vector3df v1)
{
    if(fabs(v0.X-v1.X) < 0.25 &&
           fabs(v0.Y-v1.Y) < 0.25 &&
           fabs(v0.Z-v1.Z) < 0.25)
           {
            return true;
           }

    if(fabs(v0.X-v1.X) < 1.0 &&
           fabs(v0.Y-v1.Y) < 1.0 &&
           fabs(v0.Z-v1.Z) < 1.0)
           {
              // return true;
            std::cout<<"*warning* is_same_point("<<v0.X<<","<<v1.X<<" "<<v0.Y<<","<<v1.Y<<" "<<v0.Z<<","<<v1.Z<<")\n";
           }
    return false;
}

bool is_same_point(core::vector2df v0, core::vector2df v1)
{
    if(fabs(v0.X-v1.X) < 0.02 &&
           fabs(v0.Y-v1.Y) < 0.02)
           {
            return true;
           }
    return false;
}

bool is_same_point(f32 f1, f32 f2)
{
    if(fabs(f2-f1) < 0.02)
           {
            return true;
           }
    return false;
}

bool is_colinear_point(core::line3df line, core::vector3df v)
{
    core::vector3df dist = line.getClosestPoint(v) - v;
    if(dist.getLength()<POINT_IS_COLINEAR_DIST)
        return true;
    if(dist.getLength()<1.0)
        {
           // std::cout<<"*warning* is_colinear_point "<<dist.getLength()<<"\n";
        }
    return false;
}

bool is_coplanar_point(core::plane3df plane, core::vector3df v)
{
    f32 dist = fabs(plane.getDistanceTo(v));
    if(dist < POINT_IS_COPLANAR_DIST)
        return true;
    if(dist < 0.1)
        {
          //  std::cout<<"*warning* is_coplanar_point "<<dist<<"\n";
        }
    return false;
}

bool is_parallel_normal(core::vector3df v0,core::vector3df v1)
{
    f32 dp = fabs(v0.dotProduct(v1));
    if(dp > PLANE_IS_COPLANAR_DOT)
    {
        if(dp<0.9999)
        {
            //std::cout<<"**warning coplanar : "<<dp<<"(returned true) ";
            //std::cout<<v0.X<<","<<v0.Y<<","<<v0.Z<<" vs "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
        }
        return true;
    }
    if(dp > 0.99)
        {
           // std::cout<<"*warning* is_parallel_normal "<<dp<<" (returned false) ";
           // std::cout<<v0.X<<","<<v0.Y<<","<<v0.Z<<" vs "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
        }
    else
        return false;
}

bool BoxIntersectsWithBox(const core::aabbox3d<f32>& A, const core::aabbox3d<f32>& B)
		{
			return (A.MinEdge.X <= B.MaxEdge.X + BOX_INTERSECT_TOLERANCE &&
                    A.MinEdge.Y <= B.MaxEdge.Y + BOX_INTERSECT_TOLERANCE &&
                    A.MinEdge.Z <= B.MaxEdge.Z + BOX_INTERSECT_TOLERANCE &&
                    A.MaxEdge.X >= B.MinEdge.X - BOX_INTERSECT_TOLERANCE &&
                    A.MaxEdge.Y >= B.MinEdge.Y - BOX_INTERSECT_TOLERANCE &&
                    A.MaxEdge.Z >= B.MinEdge.Z - BOX_INTERSECT_TOLERANCE);
		}

//=================================================================\
//Classes


void polyfold::rotate(core::matrix4 MAT)
{
    for(poly_vert & vert: vertices)
    {
        MAT.rotateVect(vert.V);
    }
    for(poly_face & face: faces)
    {
        MAT.rotateVect(face.m_normal);
        face.m_normal.normalize();
        MAT.rotateVect(face.m_center);
        MAT.rotateVect(face.uv_origin);
    }
    for(surface_group& sg: surface_groups)
    {
        MAT.rotateVect(sg.point);
        MAT.rotateVect(sg.vec);
        sg.vec.normalize();
        MAT.rotateVect(sg.vec1);
        sg.vec1.normalize();
    }

    recalc_bbox();

    for(int f_i=0;f_i<this->faces.size();f_i++)
        for(int p_i=0;p_i<this->faces[f_i].loops.size();p_i++)
        {
            this->calc_loop_bbox(f_i,p_i);

            if(faces[f_i].loops[p_i].topo_group==LOOP_SOLID)
                set_loop_solid(f_i,p_i);
            else if(faces[f_i].loops[p_i].topo_group==LOOP_HOLLOW)
                set_loop_open(f_i,p_i);
            else std::cout<<f_i<<" "<<p_i<<" undefined "<<faces[f_i].loops[p_i].topo_group<<"\n";
        }
}

void polyfold::translate(core::matrix4 MAT)
{
    for(poly_vert & vert: vertices)
    {
        MAT.translateVect(vert.V);
    }
    for(poly_face & face: faces)
    {
        MAT.translateVect(face.m_center);
        MAT.translateVect(face.uv_origin);
    }
    for(surface_group& sg: surface_groups)
    {
        MAT.translateVect(sg.point);
    }
    recalc_bbox();

    for(int f_i=0;f_i<this->faces.size();f_i++)
        for(int p_i=0;p_i<this->faces[f_i].loops.size();p_i++)
        {
            this->calc_loop_bbox(f_i,p_i);
        }
}

void polyfold::make_convex()
    {
        if(topology == TOP_CONCAVE)
        {
            for(poly_face &face : faces)
                face.flip_normal();
            topology = TOP_CONVEX;
        }
        else if(topology == TOP_CONVEX)
        {
            //do nothing
        }
        else
        {
            std::cout<<"... calculating topology\n";
            topology=TOP_CONVEX;
            recalc_faces();
        }
    }
void polyfold::make_concave()
    {
        if(topology == TOP_CONVEX)
        {
            for(poly_face &face : faces)
                face.flip_normal();
            topology = TOP_CONCAVE;
        }
        else if(topology == TOP_CONCAVE)
        {
            //do nothing
        }
        else
        {
            std::cout<<"... calculating topology\n";
            topology=TOP_CONCAVE;
            recalc_faces();
        }
    }

void polyfold::recalc_faces()
{
    recalc_bbox();

    for(int f_i=0;f_i<this->faces.size();f_i++)
    {
        calc_normal(f_i);

        for(int p_i=0;p_i<this->faces[f_i].loops.size();p_i++)
        {
            this->calc_loop_bbox(f_i,p_i);

            if(faces[f_i].loops[p_i].topo_group==LOOP_SOLID)
                set_loop_solid(f_i,p_i);
            else if(faces[f_i].loops[p_i].topo_group==LOOP_HOLLOW)
                set_loop_open(f_i,p_i);
            else std::cout<<"* warning * loop "<<f_i<<" "<<p_i<<" undefined "<<faces[f_i].loops[p_i].topo_group<<"\n";
        }
    }

    LineHolder nograph;
    if(topology==TOP_CONVEX)
    {
        make_convex2(nograph);
    }
    else
    {
        make_convex2(nograph);
        for(poly_face& f : faces)
            f.flip_normal();
        topology=TOP_CONCAVE;
    }
}


void polyfold::make_convex2(LineHolder& graph)
{
    LineHolder nograph;

    for(int f_i=0;f_i<faces.size();f_i++)
    {
        if(faces[f_i].loops.size()==0)
            continue;

        polyfold verts;
        //graph.lines.push_back(core::line3df(v0,this->vertices[w].V));

        for(int e_0=0;e_0<faces[f_i].edges.size();e_0++)
        {

            core::vector3df axis = faces[f_i].m_normal;

            int e_i = faces[f_i].edges[e_0];

            core::vector3df v0;
            get_facial_point(f_i,e_i, get_edge_loop_no(f_i,e_i),v0,nograph);

            verts.get_point_or_add(v0);

            for(int f_j=0; f_j<this->faces.size();f_j++)
            {
                if(f_i==f_j)
                    continue;

                poly_face f=this->faces[f_j];
                core::plane3df f_plane = core::plane3df(f.m_center,f.m_normal);

                core::vector3df ipoint;

                if(f_plane.getIntersectionWithLine(v0,axis,ipoint) && this->is_point_on_face(f_j,ipoint))
                {
                    verts.get_point_or_add(ipoint);
                    //graph.points.push_back(ipoint);
                }
            }
            //std::cout<<"ipoints: "<<verts.vertices.size()<<"\n";

            if(verts.vertices.size()%2==0)
            {


                sort_inline_vertices(verts);
                core::vector3df N = verts.vertices[0].V - verts.vertices[verts.vertices.size()-1].V;
                N.normalize();

                for(int i=0;i<verts.vertices.size();i++)
                {
                    if(is_same_point(v0,verts.vertices[i].V))
                    {
                        if(faces[f_i].m_normal.dotProduct(N) < 0)
                        {
                            faces[f_i].flip_normal();
                        }
                        goto next_face;
                    }
                    N*=(-1);
                }
            }
            else
                graph.points.push_back(v0);
        }
        next_face:
        int z=0;
    }

    topology=TOP_CONVEX;
}

void polyfold::draw(video::IVideoDriver* driver, const video::SMaterial material, bool normals)
    {
        driver->setTransform(video::ETS_WORLD, core::IdentityMatrix);
        driver->setMaterial(material);
        for(int i =0; i<edges.size(); i++)
        {
            if(edges[i].topo_group != -1)
                driver->draw3DLine(vertices[edges[i].v0].V,vertices[edges[i].v1].V,video::SColor(12,12,0,48));
        }

        if(normals)
            for(poly_face face : this->faces)
            {
                driver->draw3DLine(face.m_center,face.m_center+face.m_normal*16,video::SColor(255,255,255,255));

            }
    }

void polyfold::calc_center(poly_face& face)
{
    f32 xsum=0;
    f32 ysum=0;
    f32 zsum=0;

    for(int i=0; i < face.vertices.size(); i++)
    {
        xsum+=vertices[face.vertices[i]].V.X;
        ysum+=vertices[face.vertices[i]].V.Y;
        zsum+=vertices[face.vertices[i]].V.Z;
    }

    xsum/=face.vertices.size();
    ysum/=face.vertices.size();
    zsum/=face.vertices.size();

    face.m_center = core::vector3df(xsum,ysum,zsum);
}

void polyfold::calc_center(int f_i)
{
    f32 xsum=0;
    f32 ysum=0;
    f32 zsum=0;

    for(int i=0; i < this->faces[f_i].vertices.size(); i++)
    {
        xsum+=vertices[this->faces[f_i].vertices[i]].V.X;
        ysum+=vertices[this->faces[f_i].vertices[i]].V.Y;
        zsum+=vertices[this->faces[f_i].vertices[i]].V.Z;
    }

    xsum/=this->faces[f_i].vertices.size();
    ysum/=this->faces[f_i].vertices.size();
    zsum/=this->faces[f_i].vertices.size();

    this->faces[f_i].m_center = core::vector3df(xsum,ysum,zsum);
}

void polyfold::calc_normal(int f_i)
{
    this->calc_center(f_i);

    if(this->faces[f_i].vertices.size()>2)
        {
            int v_i0 = this->faces[f_i].vertices[0];
            int v_i1 = this->faces[f_i].vertices[1];
            int v_i2 = this->faces[f_i].vertices[2];

            core::vector3df v1 = vertices[v_i0].V - vertices[v_i1].V;
            core::vector3df v2 = vertices[v_i1].V - vertices[v_i2].V;
            core::vector3df cross = v1.crossProduct(v2);
            cross.normalize();

            this->faces[f_i].m_normal = cross;
            this->faces[f_i].bFlippedNormal = false;
        }
}

void polyfold::calc_loop_bbox(int f_i, int p_i)
{
    core::matrix4 R = this->faces[f_i].get2Dmat();
    core::vector3df r;

    poly_loop *loop = &this->faces[f_i].loops[p_i];

    R.rotateVect(r,this->vertices[loop->vertices[0]].V);

    loop->min_x=r.X;
    loop->max_x=r.X;
    loop->min_z=r.Z;
    loop->max_z=r.Z;

    for(int v_i : loop->vertices)
        {
            R.rotateVect(r,this->vertices[v_i].V);
            loop->min_x=std::min(loop->min_x,r.X);
            loop->max_x=std::max(loop->max_x,r.X);
            loop->min_z=std::min(loop->min_z,r.Z);
            loop->max_z=std::max(loop->max_z,r.Z);
        }
}


void polyfold::calc_loop_bbox(poly_face& face, poly_loop &loop)
{
    core::matrix4 R = face.get2Dmat();
    core::vector3df r;


    R.rotateVect(r,this->vertices[loop.vertices[0]].V);

    loop.min_x=r.X;
    loop.max_x=r.X;
    loop.min_z=r.Z;
    loop.max_z=r.Z;

    for(int v_i : loop.vertices)
        {
            R.rotateVect(r,this->vertices[v_i].V);
            loop.min_x=std::min(loop.min_x,r.X);
            loop.max_x=std::max(loop.max_x,r.X);
            loop.min_z=std::min(loop.min_z,r.Z);
            loop.max_z=std::max(loop.max_z,r.Z);
        }
}



bool polyfold::is_closed_loop(int f_i, int p_i)
{
    f32 testz = (this->faces[f_i].loops[p_i].max_z - this->faces[f_i].loops[p_i].min_z)*0.5 + this->faces[f_i].loops[p_i].min_z;
    f32 testx = this->faces[f_i].loops[p_i].min_x - 10;
    int res = this->left_right_test(f_i, p_i,testx,testz);
    if(res==0)
    {
        return true;
    }
    return false;
}


void polyfold::set_loop_solid(int f_i, int p_i)
{
    poly_loop* loop = &this->faces[f_i].loops[p_i];

    if(loop->vertices.size() == 0)
        return;

    this->calc_loop_bbox(f_i,p_i);

    f32 testz = (loop->max_z - loop->min_z)*0.5 + loop->min_z;
    f32 testx = loop->min_x - 10;
    int res = this->left_right_test(f_i,p_i,testx,testz);
    if(res==1)
    {
        loop->reverse();
    }
}

void polyfold::set_loop_open(int f_i, int p_i)
{
    poly_loop* loop = &this->faces[f_i].loops[p_i];

    if(loop->vertices.size() == 0)
        return;

    this->calc_loop_bbox(f_i,p_i);

    f32 testz = (loop->max_z - loop->min_z)*0.5 + loop->min_z;
    f32 testx = loop->min_x - 10;
    int res = this->left_right_test(f_i,p_i,testx,testz);
    if(res==0)
    {
        loop->reverse();
    }
}

void polyfold::sort_loops_inner(int f_i)
{
    poly_face* face = &this->faces[f_i];

    for(int i = 0; i<face->loops.size(); i++)
    {
        if(face->loops[i].vertices.size() > 0)
        {
            this->set_loop_solid(f_i,i);
            face->loops[i].depth=0;
        }
    }

    for(int i = 0; i<face->loops.size(); i++)
        for(int j = i+1; j<face->loops.size(); j++)
    {

        if(face->loops[i].vertices.size() ==0 || face->loops[j].vertices.size() == 0)
            continue;

        if(this->is_inner_loop(f_i,i,j))
            face->loops[i].depth ++;
        else if(this->is_inner_loop(f_i,j,i))
            face->loops[j].depth ++;
    }
}

void polyfold::sort_loops(int f_i)
{
    poly_face* face = &this->faces[f_i];

    for(int i = 0; i<face->loops.size(); i++)
    {
        if(face->loops[i].vertices.size() > 0)
            this->set_loop_solid(f_i,i);
    }

    for(int i = 0; i<face->loops.size(); i++)
    {
        if(face->loops[i].type == LOOP_OUTER)
            face->loops[i].depth= 0;
        else
            face->loops[i].depth= -1;
    }

    //Check for nested loops
    for(int i = 0; i<face->loops.size(); i++)
        for(int j = i+1; j<face->loops.size(); j++)
    {

        if(face->loops[i].vertices.size() ==0 || face->loops[j].vertices.size() == 0)
            continue;

        bool b1=true;
        bool b2=true;

        for(int v_i : face->loops[i].vertices)
            if(!this->is_point_in_loop(f_i,j,this->vertices[v_i].V))
                b1 = false;
        for(int v_j : face->loops[j].vertices)
            if(!this->is_point_in_loop(f_i,i,this->vertices[v_j].V))
                b2 = false;

        if(b1 && face->loops[j].type == LOOP_OUTER)
            face->loops[i].depth ++;
        else if(b2 && face->loops[i].type == LOOP_OUTER)
            face->loops[j].depth ++;
    }

    for(int i = 0; i<face->loops.size(); i++)
        {
            if(face->loops[i].type == LOOP_OUTER && face->loops[i].depth%2 == 1)
            {
                face->loops[i].reverse();
                face->loops[i].topo_group = LOOP_HOLLOW;
            }
            else
                face->loops[i].topo_group = LOOP_SOLID;
        }
}


void polyfold::recalc_bbox()
{
    if(this->vertices.size() > 0)
    {
    this->bbox.reset(this->vertices[0].V);
    for(poly_vert v : this->vertices)
        this->bbox.addInternalPoint(v.V);
    }
    else
        this->bbox.reset(core::vector3df(0,0,0));
}

void polyfold::recalc_bbox_and_loops()
{
    for(int f_i=0;f_i<this->faces.size();f_i++)
    {
        LineHolder nograph;
        this->calc_loops4(f_i,nograph);

        this->sort_loops(f_i);
        for(int p_i = 0; p_i< this->faces[f_i].loops.size(); p_i++)
        {
            if(this->faces[f_i].loops[p_i].type == LOOP_INNER)
                this->faces[f_i].loops[p_i].vertices.clear();
            else
                this->calc_loop_bbox(f_i,p_i);
        }
    }

    this->reduce_edges_vertices2();

    if(this->vertices.size()>0)
    {
        this->bbox.reset(this->vertices[0].V);
        for(poly_vert v : this->vertices)
            this->bbox.addInternalPoint(v.V);
    }
}

int polyfold::get_point_or_add(core::vector3df point)
{
    for( int i=0; i<this->vertices.size(); i++)
    {
        poly_vert vert=this->vertices[i];
        if(is_same_point(vert.V,point))
           {
            return i;
           }
    }
    this->vertices.push_back(poly_vert(point.X,point.Y,point.Z));
    return this->vertices.size()-1;
}

int polyfold::find_point(core::vector3df point)
{
    for( int i=0; i<this->vertices.size(); i++)
    {
        poly_vert vert=this->vertices[i];
        if(is_same_point(vert.V,point))
           {
            return i;
           }
    }
    return -1;
}

bool polyfold::is_point_in_loop(int f_i, int p_i, core::vector3df v)
{
    core::matrix4 R = this->faces[f_i].get2Dmat();
    core::vector3df V = v;
    R.rotateVect(V);
    f32 small_number = LOOP_BBOX_SMALL_NUMBER;
    if(V.X < this->faces[f_i].loops[p_i].min_x - small_number || V.X > this->faces[f_i].loops[p_i].max_x + small_number ||
        V.Z < this->faces[f_i].loops[p_i].min_z - small_number || V.Z > this->faces[f_i].loops[p_i].max_z + small_number)
        {
        return false;
        }

    if(this->is_closed_loop(f_i,p_i))
        return (this->left_right_test(f_i, p_i, V.X,V.Z)==1);
    else
        return (this->left_right_test(f_i, p_i, V.X,V.Z,true)==0);
}

bool polyfold::is_point_on_face(int f_i, core::vector3df v)
{
    int n=0;

    for(int p_i=0; p_i< this->faces[f_i].loops.size(); p_i++)
    {
        if(this->faces[f_i].loops[p_i].vertices.size() > 0 && is_point_in_loop(f_i,p_i,v)==true)
        {
            if( this->is_closed_loop(f_i,p_i))
                n++;
            else
                n--;
        }
    }
    return n>0;
}

int polyfold::left_right_test(int f_i, int p_i, f32 vx, f32 vz, bool is_open, int n_tries)
{
    f32 small_number = LEFT_RIGHT_TEST_SMALL_NUMBER;

    core::vector3df point;
    point.X = vx;
    point.Y = 0;
    point.Z = vz;


    std::vector<core::vector3df> verts;
    for(int v_i : this->faces[f_i].loops[p_i].vertices)
    {
        verts.push_back(this->vertices[v_i].V);
    }
    verts.push_back(verts[0]);

    core::matrix4 R = this->faces[f_i].get2Dmat();

    for(core::vector3df &v : verts)
    {
        R.rotateVect(v);
    }

    f32 closest_x=99000;
    f32 closest_z=99000;

    int status=-1; //-1 = undefined, 0 = left, 1 = right
    int try_status=-1;
    int x_status=-1;
    int z_status=-1;

    for(int i = 0 ; i<verts.size()-1; i++)
    {
        core::vector3df leftv,rightv;
        if(verts[i].X < verts[i+1].X)
        {
            leftv = verts[i];
            rightv = verts[i+1];
        }
        else
        {
            leftv = verts[i+1];
            rightv = verts[i];
        }

        if(point.X > leftv.X  - small_number &&
           point.X < rightv.X + small_number &&
           fabs(rightv.X - leftv.X) > fabs(small_number))
        {
            f32 z_intersect;
            f32 m = (rightv.Z - leftv.Z)/ (rightv.X - leftv.X);
            z_intersect = m*(point.X-leftv.X)+leftv.Z;

           if(fabs(fabs(point.Z - z_intersect)-closest_z)<fabs(small_number))
           {
                if(verts[i].X < verts[i+1].X
                   && point.Z > z_intersect - small_number)
                {
                    try_status = 0; //Left
                }
                else if(verts[i].X < verts[i+1].X
                   && point.Z < z_intersect + small_number)
                {
                    try_status = 1; //Right
                }
                else if(verts[i].X > verts[i+1].X
                   && point.Z > z_intersect - small_number)
                {
                    try_status = 1; //Right
                }
                else if(verts[i].X > verts[i+1].X
                   && point.Z < z_intersect + small_number)
                {
                    try_status = 0; //Left
                }

                if(try_status != z_status)
                {
                    z_status = -1; //ambiguous
                }
           }
           else if(fabs(point.Z - z_intersect)<closest_z)
            {
                if(verts[i].X < verts[i+1].X
                   && point.Z > z_intersect - small_number)
                {
                    z_status = 0; //Left
                    closest_z = fabs(point.Z - z_intersect);
                }
                else if(verts[i].X < verts[i+1].X
                   && point.Z < z_intersect + small_number)
                {
                    z_status = 1; //Right
                    closest_z = fabs(point.Z - z_intersect);
                }
                else if(verts[i].X > verts[i+1].X
                   && point.Z > z_intersect - small_number)
                {
                    z_status = 1; //Right
                    closest_z = fabs(point.Z - z_intersect);
                }
                else if(verts[i].X > verts[i+1].X
                   && point.Z < z_intersect + small_number)
                {
                    z_status = 0; //Left
                    closest_z = fabs(point.Z - z_intersect);
                }
            }
        }
        if (point.Z > std::min(verts[i].Z,verts[i+1].Z) - small_number &&
           point.Z < std::max(verts[i].Z,verts[i+1].Z) + small_number &&
           fabs(rightv.Z - leftv.Z) > fabs(small_number))
        {
            f32 x_intersect;
            if(fabs(rightv.X - leftv.X)<small_number)
            {
                x_intersect = leftv.X;
            }
            else
            {
                f32 m = (rightv.Z - leftv.Z)/ (rightv.X - leftv.X);
                x_intersect = ((point.Z-leftv.Z))/m+leftv.X;
            }
            if(fabs(fabs(point.X - x_intersect)-closest_x)<fabs(small_number))
            {

                if(verts[i].Z < verts[i+1].Z
                   && point.X < x_intersect + small_number)
                {
                    try_status = 0; //Left
                }
                else if(verts[i].Z < verts[i+1].Z
                   && point.X > x_intersect - small_number)
                {
                    try_status = 1; //Right
                }
                else if(verts[i].Z > verts[i+1].Z
                   && point.X < x_intersect + small_number)
                {
                    try_status = 1; //Right
                }
                else if(verts[i].Z > verts[i+1].Z
                   && point.X > x_intersect - small_number)
                {
                    try_status = 0; //Left
                }

                if(try_status != x_status)
                {
                    x_status = -1; //ambiguous
                }
            }
            else if(fabs(point.X - x_intersect)<closest_x)
            {
                if(verts[i].Z < verts[i+1].Z
                   && point.X < x_intersect + small_number)
                {
                    x_status = 0; //Left
                    closest_x = fabs(point.X - x_intersect);
                }
                else if(verts[i].Z < verts[i+1].Z
                   && point.X > x_intersect - small_number)
                {
                    x_status = 1; //Right
                    closest_x = fabs(point.X - x_intersect);
                }
                else if(verts[i].Z > verts[i+1].Z
                   && point.X < x_intersect + small_number)
                {
                    x_status = 1; //Right
                    closest_x = fabs(point.X - x_intersect);
                }
                else if(verts[i].Z > verts[i+1].Z
                   && point.X > x_intersect - small_number)
                {
                    x_status = 0; //Left
                    closest_x = fabs(point.X - x_intersect);
                }
            }
        }
    }

    if(closest_x < LEFT_RIGHT_TEST_INCLUDE_NUMBER || closest_z< LEFT_RIGHT_TEST_INCLUDE_NUMBER)
    {
        x_status=1;
        z_status=1;
    }

    if(x_status != z_status && x_status !=-1 && z_status !=-1)
    {
        status = -1;
    }
    else if(x_status != -1) status = x_status;
    else if(z_status != -1) status = z_status;

    if(status == -1)
    {
        if(n_tries>0)
        {
            if(n_tries < 2)
            {
                std::cout<<"L/R TEST_1 attempt "<<vx<<","<<vz<<" ("<<n_tries<<")\n";
                std::cout<<"   x: "<<closest_x<<" / "<<x_status<<" "<<"z: "<<closest_z<<" / "<<z_status<<"\n";
                std::cout<<"bounds: "<<this->faces[f_i].loops[p_i].min_x<<","<<this->faces[f_i].loops[p_i].max_x<<
                                    "  "<<this->faces[f_i].loops[p_i].min_z<<","<<this->faces[f_i].loops[p_i].max_z<<"\n";
            }
            f32 newx = vx;
            f32 newz = vz;

            if(closest_x > closest_z)
            {
            newx = vx - 1;
            if(newx < this->faces[f_i].loops[p_i].min_x - small_number || newx > this->faces[f_i].loops[p_i].max_x + small_number)
                newx = vx + 1;
            }
            else
            {
            newz = vz - 1;
            if(newz < this->faces[f_i].loops[p_i].min_z - small_number || newz > this->faces[f_i].loops[p_i].max_z + small_number)
                newz = vz + 1;
            }

            return this->left_right_test(f_i,p_i,newx,newz, is_open, n_tries-1);
        }
        std::cout<<"**warning - undefined left right test (T2) "<<f_i<<" "<<p_i<<" **\n";

        for(core::vector3df v : verts)
        {
            std::cout<<v.X<<","<<v.Z<<" ";
        }
        std::cout<<"("<<vx<<","<<vz<<")";

        status = 1;
    }

   return status;
}

bool polyfold::bisect_edge(int edge_no,int v_no, int g0, int g1)
{

    if(this->edges[edge_no].v0 == v_no)
    {
        return false;
    }
    else if(this->edges[edge_no].v1 == v_no)
    {
        return false;
    }
    else if(this->edges[edge_no].topo_group== -1)
        return false;

    this->edges.push_back(poly_edge(this->edges[edge_no].v0,v_no,g0));
    this->edges.push_back(poly_edge(this->edges[edge_no].v1,v_no,g1));

    int new_edge0 = this->edges.size()-2;
    int new_edge1 = this->edges.size()-1;

    this->edges[edge_no].topo_group=-1;
    core::vector3df v0=this->getVertex(new_edge0,0).V;
    core::vector3df v1=this->getVertex(new_edge0,1).V;

    v0=this->getVertex(new_edge1,0).V;
    v1=this->getVertex(new_edge1,1).V;

    for(poly_face &face : this->faces)
    {
        for(int i =0; i< face.edges.size();i++)
        {
            if(face.edges[i] == edge_no)
            {
             face.edges[i]=new_edge0;
             face.edges.push_back(new_edge1);
             face.addVertex(v_no);
            }
        }
    }
    return true;
}

poly_vert polyfold::getVertex(int f_i, int e_i, int v_i)
{
    if(v_i == 0)
        return this->vertices[this->edges[this->faces[f_i].edges[e_i]].v0];
    else if(v_i==1)
        return this->vertices[this->edges[this->faces[f_i].edges[e_i]].v1];
    else
        {
            return poly_vert(0,0,0);
        }
}

poly_vert polyfold::getVertex(int e_i, int v_i)
{
    if(v_i == 0)
        return this->vertices[this->edges[e_i].v0];
    else if(v_i==1)
        return this->vertices[this->edges[e_i].v1];
    else
        {
            return poly_vert(0,0,0);
        }
}

std::vector<int> polyfold::get_edges_from_point(int f_i, int v)
{
    std::vector<int> ret;

    for(int e_i : this->faces[f_i].edges)
    {
        if((this->edges[e_i].v0 == v || this->edges[e_i].v1 == v ) && this->edges[e_i].topo_group != -1)
        ret.push_back(e_i);
    }

    return ret;
}

std::vector<int> polyfold::get_edges_from_point(int f_i, int e_0, int v)
{
    std::vector<int> ret;

    for(int e_i : this->faces[f_i].edges)
    {
        if((this->edges[e_i].v0 == v || this->edges[e_i].v1 == v ) && (e_i != e_0) && this->edges[e_i].topo_group != -1)
            ret.push_back(e_i);
    }

    return ret;
}


std::vector<int> polyfold::get_all_edges_from_point(int e_0, int v)
{
    std::vector<int> ret;

    for(int e_i = 0; e_i<this->edges.size(); e_i++)
    {
        if((this->edges[e_i].v0 == v || this->edges[e_i].v1 == v ) && (e_i != e_0) && this->edges[e_i].topo_group != -1)
            ret.push_back(e_i);
    }

    return ret;
}


std::vector<int> polyfold::get_edges_from_2edges(int f_i, int e_0, int e_1)
{
    std::vector<int> ret;

    int v;

    if(this->edges[e_0].v0 == this->edges[e_1].v0 || this->edges[e_0].v0 == this->edges[e_1].v1)
        v = this->edges[e_0].v0;
    else
        v = this->edges[e_0].v1;

    for(int e_i : this->faces[f_i].edges)
    {
        if((this->edges[e_i].v0 == v || this->edges[e_i].v1 == v ) && (e_i != e_0) && (e_i != e_1) && this->edges[e_i].topo_group != -1)
            ret.push_back(e_i);
    }

    return ret;
}


std::vector<int> polyfold::get_connecting_edges(int edge_no)
{
    std::vector<int> ret;

    int v0 = this->edges[edge_no].v0;
    int v1 = this->edges[edge_no].v1;

    for(int e_i = 0; e_i<this->edges.size(); e_i++)
    {
        if(e_i != edge_no && (this->edges[e_i].v0 == v0 || this->edges[e_i].v1 == v1 || this->edges[e_i].v0 == v1 || this->edges[e_i].v1 == v0))
        ret.push_back(e_i);
    }

    return ret;
}

//===================================================================
// functions

bool polyfold::edge_exists(int v0,int v1)
{
    for(int e_i=0; e_i<this->edges.size(); e_i++)
    {
        poly_edge edge = this->edges[e_i];
        if((edge.v0 == v0 && edge.v1 == v1) ||  (edge.v1 == v0 && edge.v0 == v1))
            return true;
    }
    return false;
}

int polyfold::get_edge_or_add(int v0,int v1,int group)
{
    for(int e_i=0; e_i<this->edges.size(); e_i++)
    {
        poly_edge edge = this->edges[e_i];
        if((edge.v0 == v0 && edge.v1 == v1) ||  (edge.v1 == v0 && edge.v0 == v1))
            return e_i;
    }
    this->edges.push_back(poly_edge(v0,v1));
    this->edges[this->edges.size()-1].topo_group = group;
    return this->edges.size()-1;
}


int polyfold::find_edge(int v0,int v1)
{
    for(int e_i=0; e_i<this->edges.size(); e_i++)
    {
        poly_edge edge = this->edges[e_i];
        if((edge.v0 == v0 && edge.v1 == v1) ||  (edge.v1 == v0 && edge.v0 == v1))
            return e_i;
    }
    return -1;
}

int polyfold::find_edge(core::vector3df v0, core::vector3df v1)
{
    for(int e_i=0; e_i<this->edges.size(); e_i++)
    {
        poly_edge edge = this->edges[e_i];
        if((is_same_point(this->getVertex(e_i,0).V, v0) &&  is_same_point(this->getVertex(e_i,1).V, v1))
           || (is_same_point(this->getVertex(e_i,1).V, v0) &&  is_same_point(this->getVertex(e_i,0).V, v1)))
            return e_i;
    }
    return -1;
}

bool line_intersects_plane(core::plane3df plane, core::vector3df v0, core::vector3df v1, core::vector3df& ipoint)
{
    core::vector3df linevec = v1-v0;
    linevec.normalize();

    if(fabs(plane.Normal.dotProduct(linevec))<LINE_IS_COPLANAR_DOT)
        return false;
    else if(plane.getIntersectionWithLimitedLine(v0,v1,ipoint))
        return true;
    else if(fabs(plane.getDistanceTo(v0))<POINT_IS_COPLANAR_DIST && fabs(plane.getDistanceTo(v1))>POINT_IS_COPLANAR_DIST)
            {
                ipoint = v0;
                return true;
            }
    else if(fabs(plane.getDistanceTo(v1))<POINT_IS_COPLANAR_DIST && fabs(plane.getDistanceTo(v0))>POINT_IS_COPLANAR_DIST)
            {
                ipoint = v1;
                return true;
            }
    return false;
}

bool polyfold::point_is_coplanar(int face, core::vector3df v )
{
    core::plane3df plane = core::plane3df(this->faces[face].m_center,this->faces[face].m_normal);
    if(fabs(plane.getDistanceTo(v))<POINT_IS_COPLANAR_DIST)
        return true;
    else return false;
}
bool polyfold::point_is_on_edge(int edge, core::vector3df v )
{
    core::line3df line = core::line3df(this->getVertex(edge,0).V,this->getVertex(edge,1).V);
    core::vector3df dist = line.getClosestPoint(v) - v;
    if(dist.getLength()<POINT_IS_COLINEAR_DIST)
        return true;
    else
        return false;
}

void sort_inline_vertices(polyfold& pf)
{
    if(pf.vertices.size() < 3) return;
    std::vector<poly_vert> rvec;

    f32 d=0;
    int res=-1;
    for(int i=0;i<pf.vertices.size();i++)
        for(int j=i+1; j<pf.vertices.size(); j++)
        {
            core::vector3df r = pf.vertices[i].V - pf.vertices[j].V;
            if(r.getLength() > d)
            {
                res = i;
                d=r.getLength();
            }
        }
    core::vector3df origin= pf.vertices[res].V;
    d=0;
    f32 sofar=-10;
    res=-1;
    for(int i=0;i<pf.vertices.size();i++)
    {
        d=99999;
        for(int j=0; j<pf.vertices.size(); j++)
            {
                core::vector3df r = pf.vertices[j].V - origin;
                if(r.getLength() > sofar && r.getLength() < d)
                {
                    res=j;
                    d=r.getLength();
                }
            }
        rvec.push_back(pf.vertices[res]);
        sofar=d;
    }
    pf.vertices=rvec;
}

int polyfold::classify_point_edge(int edge, core::vector3df v0, core::vector3df v1)
{
    bool bIsBehindConvex = true;
    bool bIsFrontConvex = false;
    bool bIsFrontConcave = true;
    bool bIsBehindConcave = false;

    if(this->classify_edge(edge)==TOP_CONVEX)
    {
        for(int f_i=0; f_i<this->faces.size(); f_i++)
        {
            for(int e_i : this->faces[f_i].edges)
            {
                if(e_i == edge && this->classify_point_face(f_i,v1)!=TOP_BEHIND)
                    bIsBehindConvex = false;
                if(e_i == edge && this->classify_point_face(f_i,v1)==TOP_FRONT)
                {
                    bIsFrontConvex = true;
                }
            }
        }
        if(bIsBehindConvex)
            return TOP_BEHIND;
        else if(bIsFrontConvex)
            return TOP_FRONT;
        else return TOP_UNDEF;
    }
    else if(this->classify_edge(edge)==TOP_CONCAVE)
    {
       for(int f_i=0; f_i<this->faces.size(); f_i++)
        {
            for(int e_i : this->faces[f_i].edges)
            {
                if(e_i == edge && this->classify_point_face(f_i,v1)!=TOP_FRONT)
                    bIsFrontConcave = false;
                if(e_i == edge && this->classify_point_face(f_i,v1)==TOP_BEHIND)
                    bIsBehindConcave = true;
            }
        }
        if(bIsBehindConcave)
            return TOP_BEHIND;
        else if(bIsFrontConcave)
            return TOP_FRONT;
        else return TOP_UNDEF;
    }

    return TOP_UNDEF;
}

int polyfold::classify_point_face(int f_i, core::vector3df v)
{
    core::plane3df plane = core::plane3df(this->faces[f_i].m_center,this->faces[f_i].m_normal);

    if(plane.getDistanceTo(v)>POINT_IS_COPLANAR_DIST)
        return TOP_FRONT;
    else if(plane.getDistanceTo(v)<-POINT_IS_COPLANAR_DIST)
        return TOP_BEHIND;
    else return TOP_UNDEF;
}

int polyfold::classify_point(int face_i, core::vector3df v0, core::vector3df v1,LineHolder& graph)
{
    int RES = TOP_UNDEF;

    std::vector<int> convex_edges;
    std::vector<int> concave_edges;
    std::vector<int> undef_edges;

    int v_i = this->find_point(v0);

    if(v_i != -1)
    {
        for(int e_i =0; e_i< this->edges.size(); e_i++)
        {
            if(this->edges[e_i].topo_group != -1 && (this->edges[e_i].v0 == v_i || this->edges[e_i].v1 == v_i))
            {
                if(this->classify_edge(e_i)==EDGE_CONVEX)
                    convex_edges.push_back(e_i);
                else if(this->classify_edge(e_i)==EDGE_CONCAVE)
                    concave_edges.push_back(e_i);
                else if(this->classify_edge(e_i)==EDGE_COMPLEX)
                {
                    undef_edges.push_back(e_i);
                }
            }
        }
    }
    else
    {
        for(int e_i =0; e_i< this->edges.size(); e_i++)
        {
            if(this->edges[e_i].topo_group != -1 && this->point_is_on_edge(e_i,v0))
            {
                if(this->classify_edge(e_i)==EDGE_CONVEX)
                    convex_edges.push_back(e_i);
                else if(this->classify_edge(e_i)==EDGE_CONCAVE)
                    concave_edges.push_back(e_i);
                else if(this->classify_edge(e_i)==EDGE_COMPLEX)
                {
                    undef_edges.push_back(e_i);
                }
            }
        }
    }

    if(convex_edges.size()==0 && concave_edges.size()==0 && undef_edges.size()==0)
    {
        return this->classify_point_face(face_i,v1);
    }
    else if(undef_edges.size()>0 || (convex_edges.size()>0 && concave_edges.size()>0) )
    {
        //COMPLEX POINT / EDGE
        graph.points.push_back(v0);
       // std::cout<<"complex\n";
        //std::vector<core::vector3df> slip_vecs = this->get_edge_slip_vectors(undef_edges[0]);
        //std::cout<<v0.X<<" "<<v0.Y<<" "<<v0.Z<<" to ";
        //std::cout<<v1.X<<" "<<v1.Y<<" "<<v1.Z<<"\n";
        std::vector<int> nfaces;
        std::vector<int> mfaces;
        std::vector<int> medges;


        for(int e_i : undef_edges)
                medges.push_back(e_i);
        for(int e_i : concave_edges)
                medges.push_back(e_i);
        for(int e_i : convex_edges)
                medges.push_back(e_i);

        for(int f_i=0;f_i<this->faces.size();f_i++)
        {
            for(int e_i : this->faces[f_i].edges)
            {
                for(int e_j : undef_edges)
                if(e_i == e_j)
                    nfaces.push_back(f_i);
                for(int e_j : concave_edges)
                if(e_i == e_j)
                    nfaces.push_back(f_i);
                for(int e_j : convex_edges)
                if(e_i == e_j)
                    nfaces.push_back(f_i);
            }
        }

        for(int f_i: nfaces)
        {
            bool b= false;
            for(int f_j : mfaces)
                if(f_i==f_j)
                    b=true;
            if(!b)
                mfaces.push_back(f_i);
        }

        int ii=0;
        std::cout<<" complex edge: ";
        while(RES == TOP_UNDEF && ii < medges.size())
        {
            int e_0 = medges[ii];

             std::vector<core::vector3df> slip_vecs;
            std::cout<<e_0<<" ";

            core::vector3df v2 = this->getVertex(e_0,0).V - this->getVertex(e_0,1).V;

            std::vector<int> bfaces;
            for(int f_i : mfaces)
            {
                for(int e_i : this->faces[f_i].edges)
                {
                    if(e_i==e_0)
                        bfaces.push_back(f_i);
                }
            }

            //std::cout<<bfaces.size()<<" faces for edge... "<<e_0<<"\n";

            for(int f_i : bfaces)
            {
                core::vector3df r = v2.crossProduct(this->faces[f_i].m_normal);
                r.normalize();
                //r*=2;
                if(this->is_point_on_face(f_i,this->getVertex(e_0,1).V+v2*0.5+r))
                    slip_vecs.push_back(r);
                else
                    slip_vecs.push_back(-r);
            }
            v2.normalize();

            //std::cout<<slip_vecs.size()<<" slip vecs\n";

           // std::cout<<v2.X<<","<<v2.Y<<","<<v2.Z<<" <-- \n";
           // for(int i=0;i<slip_vecs.size();i++)
           //     std::cout<<slip_vecs[i].X<<","<<slip_vecs[i].Y<<","<<slip_vecs[i].Z<<"\n";


//            graph.points.push_back(this->getVertex(e_0,1).V+v2*0.5+r);

               // std::cout<<"aiy\n";

            for(int i=0; i<slip_vecs.size(); i++)
            {
                if(RES != TOP_UNDEF)
                    continue;

                core::vector3df w0 = v0 + v2*3 + slip_vecs[i]*3;
                core::vector3df w1 = v1 + v2*3 + slip_vecs[i]*3;
                //graph.lines.push_back(core::line3df(w0,w1));
                core::vector3df ipoint;
                f32 d = 9999;
                f32 dd;
                std::vector<f32> dist;
                std::vector<int> res;
               // std::cout<<"---\n";

               for(int f_i : mfaces)
                {
                    core::plane3df f_plane = core::plane3df(this->faces[f_i].m_center,this->faces[f_i].m_normal);
                    if(f_plane.getIntersectionWithLine(w1,v0-v1,ipoint)&& this->is_point_on_face(f_i,ipoint))
                       {
                            w1 = v1 + v2*10 + slip_vecs[i]*10;
                            f_plane.getIntersectionWithLine(w1,v0-v1,ipoint);

                            //RES = this->classify_point_face(f_i,w1);
                            dd=ipoint.getDistanceFrom(w1);
                            dist.push_back(ipoint.getDistanceFrom(w1));
                            res.push_back(this->classify_point_face(f_i,w1));
                            //std::cout<<"got a point! ("<<f_i<<") "<<dd<<", RES = "<<this->classify_point_face(f_i,w1)<<"\n";

                       }
                }
                if(res.size()>1)
                {
                    double smallest=9999;
                    int smallest_i;
                    for(int i=0;i<res.size();i++)
                        {
                            if(dist[i]<smallest)
                            {
                             smallest_i = i;
                             smallest = dist[i];
                            }
                        }
                    double dif=9999;
                    for(int i=0;i<res.size();i++)
                    {
                        if(i!= smallest_i)
                            dif=std::min(fabs(smallest - dist[i]),dif);
                    }
                    //std::cout<<"dif="<<dif<<"\n";
                    if(dif>0.01)
                    {
                        f32 d = 9999;
                        for(int i=0;i<res.size();i++)
                        {
                            if(dist[i]<d)
                            {
                                d=dist[i];
                                RES = res[i];
                            }
                        }
                    }
                }
                else if(res.size()==1)
                {
                    //std::cout<<"* ";
                    RES = res[0];
                }
            }
            ii++;
        }

        //std::cout<<" RES = "<<RES<<"\n";
        return RES;
    }

    bool bIsBehindConvex = true;
    bool bIsFrontConvex = false;
    bool bIsFrontConcave = true;
    bool bIsBehindConcave = false;

    if(convex_edges.size()>0)
    {
        for(int e_i : convex_edges)
        {
            if(this->classify_point_edge(e_i,v0,v1) != TOP_BEHIND)
                bIsBehindConvex = false;
        }

        for(int e_i : convex_edges)
        {
            if(this->classify_point_edge(e_i,v0,v1) == TOP_FRONT)
            {
                bIsFrontConvex = true;
            }
        }

        if(bIsBehindConvex)
            RES = TOP_BEHIND;
        else if(bIsFrontConvex)
            RES = TOP_FRONT;
        else RES = TOP_UNDEF;
    }
    else if(concave_edges.size()>0)
    {
        for(int e_i : concave_edges)
        {
            if(this->classify_point_edge(e_i,v0,v1) != TOP_FRONT)
               bIsFrontConcave = false;
        }

        for(int e_i : concave_edges)
        {
            if(this->classify_point_edge(e_i,v0,v1) == TOP_BEHIND)
               bIsBehindConcave = true;
        }

        if(bIsBehindConcave)
            RES = TOP_BEHIND;
        else if(bIsFrontConcave)
            RES = TOP_FRONT;
        else RES = TOP_UNDEF;
    }

    return RES;
}



int polyfold::classify_point(core::vector3df v0, LineHolder &graph)
{
    if(this->vertices.size()==0)
        return TOP_UNDEF;

    for(int w=0; w<this->vertices.size(); w++)
    {
        std::vector<core::vector3df> ipoints;
        std::vector<int> face_n;
        core::vector3df axis = v0 - this->vertices[w].V;

        graph.points.push_back(this->vertices[w].V);
        graph.lines.push_back(core::line3df(v0,this->vertices[w].V));

        for(int f_i=0; f_i<this->faces.size();f_i++)
        {
            poly_face f=this->faces[f_i];
            core::plane3df f_plane = core::plane3df(f.m_center,f.m_normal);
            core::vector3df ipoint;

            if(f_plane.getIntersectionWithLine(v0,axis,ipoint) && this->is_point_on_face(f_i,ipoint))
            {
                ipoints.push_back(ipoint);
                graph.points.push_back(ipoint);
                face_n.push_back(f_i);
            }
        }
        //std::cout<<"Ipoints: "<<ipoints.size()<<"\n";

        if(ipoints.size()>=1)
        {
            int status = -1;

            int res;
            f32 d=99999;
            for(int i=0;i<ipoints.size();i++)
            {
                f32 r=v0.getDistanceFrom(ipoints[i]);
                if(r<d && r>0.01)
                {
                    res = i;
                    d=r;
                }
            }

            int RES = TOP_UNDEF;

            LineHolder nograph;
            graph.points.push_back(ipoints[res]);
            graph.points.push_back(v0);
            RES = this->classify_point(face_n[res],ipoints[res],v0,nograph);


            if(RES != TOP_UNDEF)
            {
                //std::cout<<d<<" is d\n";
               // std::cout<<" ="<<RES<<"\n";
                return RES;
            }

        }
    }
    std::cout<<" =-1\n";
    return TOP_UNDEF;
}

surface_group polyfold::getFaceSurfaceGroup(int f_i)
{
    int sfg = this->faces[f_i].surface_group;
    return this->surface_groups[sfg];
}

bool polyfold::getSurfaceVectors(int f_i,core::vector3df &a, core::vector3df &b)
{
    surface_group sfg=surface_groups[faces[f_i].surface_group];

    core::vector3df N = faces[f_i].m_normal;
    core::vector3df iZ =  is_parallel_normal(sfg.vec,N) ? sfg.vec1.crossProduct(N) : sfg.vec.crossProduct(N);
    iZ.normalize();
    core::vector3df iX = iZ.crossProduct(N);

    a = iZ;
    b = iX;
    return true;
}


REFLECT_STRUCT_BEGIN(poly_vert)
    REFLECT_STRUCT_MEMBER(V)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(poly_loop)
    REFLECT_STRUCT_MEMBER(vertices)
    REFLECT_STRUCT_MEMBER(type)
    REFLECT_STRUCT_MEMBER(topo_group)
    REFLECT_STRUCT_MEMBER(depth)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(surface_group)
    REFLECT_STRUCT_MEMBER(type)
    REFLECT_STRUCT_MEMBER(point)
    REFLECT_STRUCT_MEMBER(vec)
    REFLECT_STRUCT_MEMBER(vec1)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(poly_face)
    //REFLECT_STRUCT_MEMBER(edges)
    //REFLECT_STRUCT_MEMBER(vertices)
    REFLECT_STRUCT_MEMBER(loops)
    REFLECT_STRUCT_MEMBER(m_normal)
    //REFLECT_STRUCT_MEMBER(m_center)
    REFLECT_STRUCT_MEMBER(texture_index)
    REFLECT_STRUCT_MEMBER(surface_group)
    REFLECT_STRUCT_MEMBER(material_group)
    REFLECT_STRUCT_MEMBER(uv_origin)
    REFLECT_STRUCT_MEMBER(bFlippedNormal)
    REFLECT_STRUCT_MEMBER(uv_mat)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(polyfold)
    REFLECT_STRUCT_MEMBER(vertices)
    REFLECT_STRUCT_MEMBER(faces)
    REFLECT_STRUCT_MEMBER(surface_groups)
    REFLECT_STRUCT_MEMBER(topology)
REFLECT_STRUCT_END()
