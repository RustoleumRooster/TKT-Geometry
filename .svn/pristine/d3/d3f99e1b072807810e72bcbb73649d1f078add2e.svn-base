
#include <irrlicht.h>
#include <iostream>
#include <fstream>
#include "csg_classes.h"
#include "utils.h"
#include "geometry_scene.h"
#include "edit_env.h"
#include "reflected_nodes.h"
#include "Reflection.h"
#include "CPLYMeshWriter.h"

using namespace irr;
using namespace std;

extern irr::video::ITexture* small_circle_tex_add_selected = NULL;
extern irr::video::ITexture* small_circle_tex_add_not_selected = NULL;
extern irr::video::ITexture* small_circle_tex_sub_selected = NULL;
extern irr::video::ITexture* small_circle_tex_sub_not_selected = NULL;
extern irr::video::ITexture* small_circle_tex_red_selected = NULL;
extern irr::video::ITexture* small_circle_tex_red_not_selected = NULL;

extern irr::video::ITexture* med_circle_tex_add_selected = NULL;
extern irr::video::ITexture* med_circle_tex_add_not_selected = NULL;
extern irr::video::ITexture* med_circle_tex_sub_selected = NULL;
extern irr::video::ITexture* med_circle_tex_sub_not_selected = NULL;
extern irr::video::ITexture* med_circle_tex_red_selected = NULL;
extern irr::video::ITexture* med_circle_tex_red_not_selected = NULL;


void addDrawLines(polyfold& pf, LineHolder& graph,LineHolder& graph2,LineHolder& graph3)
{
    if(false)
    for(int f_i=0; f_i < pf.faces.size(); f_i++)
        {
            //if((f_i==0 || f_i==5))
           //if(f_i==29)
            for(int p_i=0;p_i<pf.faces[f_i].loops.size(); p_i++)
            {
                //std::cout<<f_i<<", "<<p_i<<": "<<pf.faces[f_i].loops[p_i].vertices.size()<<" verts\n";
                //if(p_i==0)
                //if(pf.faces[f_i].loops[p_i].vertices.size()>0 && pf.faces[f_i].loops[p_i].type == LOOP_INNER)

               // if(p_i==0)
                if(pf.faces[f_i].loops[p_i].vertices.size()>0 )//&& pf.faces[f_i].loops[p_i].type == LOOP_INNER)
                {

                    std::vector<int> tempv = pf.faces[f_i].loops[p_i].vertices;
                    tempv.push_back(tempv[0]);

                    //if(pf.faces[f_i].loops[p_i].type==LOOP_INNER)
                    for(int i=0; i < tempv.size()-1; i++)
                       {

                        //std::cout<<tempv[i]<<" "<<tempv[i+1]<<", ";
                        core::vector3df v0=pf.vertices[tempv[i]].V;
                        core::vector3df v1=pf.vertices[tempv[i+1]].V;

                       if(pf.is_closed_loop(f_i,p_i))
                        //if(pf.faces[f_i].loops[p_i].depth%2==0)
                       //if(pf.faces[f_i].loops[p_i].topo_group==LOOP_SOLID)
                       // if(pf.faces[f_i].loops[p_i].topo_group==LOOP_GHOST_SOLID)
                       //if(pf.faces[f_i].loops[p_i].type==LOOP_INNER)
                            {
                                graph2.lines.push_back(core::line3df(v0,v1));
                            }
                        //else if(pf.faces[f_i],pf.faces[f_i].loops[p_i].topo_group==LOOP_UNDEF)
                        //else if(pf.faces[f_i].loops[p_i].topo_group==LOOP_HOLLOW)
                        else //if(pf.faces[f_i].loops[p_i].topo_group==LOOP_GHOST_SOLID)
                            {
                                //graph.points.push_back(v0);
                                graph.lines.push_back(core::line3df(v0,v1));
                            }
                         //else
                            {
                               // graph3.lines.push_back(core::line3df(v0,v1));
                            }
                       }
                }
            }
        }
    //std::cout<<"huh?\n";

    if(false)
    for(int e_i=0; e_i < pf.edges.size(); e_i++)
    {
        core::vector3df v0=pf.getVertex(e_i,0).V;
        core::vector3df v1=pf.getVertex(e_i,1).V;
        if(e_i==28)
        {
            //if(pf.edges[e_i].p2== 1 || pf.edges[e_i].p2== 2)
            //if(pf.edges[e_i].topo_group==3 )// || pf.edges[e_i].topo_group==3)
            {
                graph.lines.push_back(core::line3df(v0,v1));
            }
        }
    }

    //if(false)
    for(int e_i=0; e_i < pf.edges.size(); e_i++)
    {
        core::vector3df v0=pf.getVertex(e_i,0).V;
        core::vector3df v1=pf.getVertex(e_i,1).V;
        //if(e_i==48 || e_i== 49)// || e_i==41)
        {
            //std::cout<<pf.edges[33].topo_group<<" topo\n";
            if(true)
            //if(pf.edges[e_i].topo_group==3 )// || pf.edges[e_i].topo_group==3)
            {
                graph.lines.push_back(core::line3df(v0,v1));
                //std::cout<<"edge "<<e_i<< "("<<my_poly.edges[e_i].topo_group<<") :   "<<v0.X<<","<<v0.Y<<","<<v0.Z<<" to "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
            }
            else if(pf.edges[e_i].topo_group==0)// || pf.edges[e_i].topo_group==3)
            {
                graph2.lines.push_back(core::line3df(v0,v1));
            }
            else if(pf.edges[e_i].topo_group==1)// || pf.edges[e_i].topo_group==3)
            {
                graph3.lines.push_back(core::line3df(v0,v1));
            }
        }
    }


   //std::cout<<pf.vertices.size()<<"\n";
  //  if(false)
    for(int v_i=0;v_i<pf.vertices.size();v_i++)
        {
            core::vector3df v0 = pf.vertices[v_i].V;
            graph.points.push_back(v0);
         //   std::cout<<v_i<<":  "<<v0.X<<","<<v0.Y<<","<<v0.Z<<"\n";
        }

    if(false)
    for(int f_i=0; f_i < pf.faces.size(); f_i++)
    {
        core::vector3df v0 =pf.faces[f_i].m_normal;
        std::cout<<f_i<<": "<<v0.X<<","<<v0.Y<<","<<v0.Z<<"\n";
    }

    if(false)
    for(int f_i=0; f_i < pf.faces.size(); f_i++)
    {
        if(f_i==5)
        {

        for(int v_i : pf.faces[f_i].vertices)
        {
            graph.points.push_back(pf.vertices[v_i].V);
        }
        //std::cout<<"n edges = "<<pf.faces[f_i].edges.size()<<"\n";
        for(int i=0;i<pf.faces[f_i].edges.size();i++)
        {
            //if(i==0)
            {
                int e_i = pf.faces[f_i].edges[i];
               // std::cout<<i<<" "<<e_i<<" ("<<pf.edges[e_i].topo_group<<") : "<<pf.edges[e_i].v0<<" "<<pf.edges[e_i].v1<<"\n";
                //if(e_i==13)
               {
                core::vector3df v0=pf.getVertex(e_i,0).V;
                core::vector3df v1=pf.getVertex(e_i,1).V;
                //std::cout<<pf.edges[e_i].v0<<" = "<<v0.X<<","<<v0.Y<<","<<v0.Z<<"\n";
                //std::cout<<pf.edges[e_i].v1<<" = "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
                //graph.points.push_back(v0);
                //graph.points.push_back(v1);
                //if(true)
                if(pf.edges[e_i].topo_group==3 )//|| pf.edges[e_i].topo_group==3)// || pf.edges[e_i].topo_group==3)
                {
                    graph.lines.push_back(core::line3df(v0,v1));
                    //std::cout<<"edge "<<e_i<< "("<<my_poly.edges[e_i].topo_group<<") :   "<<v0.X<<","<<v0.Y<<","<<v0.Z<<" to "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
                }
                else if(pf.edges[e_i].topo_group==0)// || pf.edges[e_i].topo_group==3)
                {
                    graph2.lines.push_back(core::line3df(v0,v1));
                }
                else if(pf.edges[e_i].topo_group==1)// || pf.edges[e_i].topo_group==3)
                {
                    graph3.lines.push_back(core::line3df(v0,v1));
                }
               }
            }
        }
        }
       //std::cout<<" a \n";
    }

    if(false)
    for(int f_i=0; f_i < pf.faces.size(); f_i++)
    {
        core::vector3df w0 = pf.faces[f_i].m_center;
        core::vector3df w1 = w0 +  pf.faces[f_i].m_normal*10;
        graph2.lines.push_back(core::line3df(w0,w1));

        for(int i=0;i<pf.faces[f_i].edges.size();i++)
        {
                int e_i = pf.faces[f_i].edges[i];
                core::vector3df v0=pf.getVertex(e_i,0).V;
                core::vector3df v1=pf.getVertex(e_i,1).V;
                graph.lines.push_back(core::line3df(v0,v1));
        }
    }



    if(false)
    for(int e_i=0; e_i < pf.edges.size(); e_i++)
    {
        core::vector3df v0=pf.getVertex(e_i,0).V;
        core::vector3df v1=pf.getVertex(e_i,1).V;
        if(e_i%2 )
        {
            graph.lines.push_back(core::line3df(v0,v1));
        }
        else
            graph2.lines.push_back(core::line3df(v0,v1));
    }

    LineHolder nograph;
    //pf.classify_edges(nograph);

    if(false)
    for(int e_i=0; e_i < pf.edges.size(); e_i++)
    {
        core::vector3df v0=pf.getVertex(e_i,0).V;
        core::vector3df v1=pf.getVertex(e_i,1).V;
        //if(e_i == 16)
            {
           // std::cout<<e_i<<" edge!\n";
            //if(pf.edges[e_i].topo_group==-1)// || pf.edges[e_i].topo_group==3)
            if(pf.edges[e_i].topo_group == -1) continue;

            //if(pf.classify_edge2(e_i)== TOP_CONVEX)
            if(pf.edges[e_i].conv == EDGE_CONVEX )//|| pf.edges[e_i].conv == EDGE_CONCAVE)
            //if(true)
            {
                graph2.lines.push_back(core::line3df(v0,v1));
               // std::cout<<"edge "<<e_i<< "("<<pf.edges[e_i].topo_group<<") :   "<<v0.X<<","<<v0.Y<<","<<v0.Z<<" to "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
            }
            //else if(pf.edges[e_i].topo_group==0 )// || pf.edges[e_i].topo_group==0)
            //else  if(pf.classify_edge(e_i)== TOP_CONCAVE)
            else if(pf.edges[e_i].conv == EDGE_SIMPLE)
            {
                graph3.lines.push_back(core::line3df(v0,v1));
                //std::cout<<"edge "<<e_i<< "("<<pf.edges[e_i].topo_group<<") :   "<<v0.X<<","<<v0.Y<<","<<v0.Z<<" to "<<v1.X<<","<<v1.Y<<","<<v1.Z<<"\n";
                //std::cout<<pf.find_edge(pf.getVertex(e_i,1).V,pf.getVertex(e_i,0).V)<<"\n";
            }
            else if(pf.edges[e_i].conv == EDGE_COMPLEX)
            {
                //std::cout<<"could not classify edge "<<e_i<<"\n";
                graph.lines.push_back(core::line3df(v0,v1));
            }
           // std::cout<<"next...\n";
        }
    }
}

video::SColor makeUniqueColor()
{
    static int i=0;
    i++;
    return video::SColor(255,i,255,255);
}

irr::video::IImage* makeSolidColorImage(video::IVideoDriver* driver, video::SColor col)
{
    int width = 8;

    video::IImage* img = driver->createImage(irr::video::ECF_A8R8G8B8,core::dimension2d<u32>(width,width));

    for(int i=0;i<width;i++)
        for(int j=0;j<width;j++)
        {
             img->setPixel(i,j,col);
        }

    return img;
}


irr::video::IImage* makeAlphaImage(video::IVideoDriver* driver,video::ITexture* texture, int alpha)
{
    video::IImage* img = driver->createImage(texture,core::vector2di(0,0),texture->getSize());
    std::cout<<texture->getSize().Width<<","<<texture->getSize().Height<<"\n";
     for(int i=0;i<texture->getSize().Width;i++)
        for(int j=0;j<texture->getSize().Height;j++)
            {
                video::SColor color = img->getPixel(i,j);
                color.setAlpha(alpha);
                img->setPixel(i,j,color);
            }
    return img;
}


irr::video::IImage* makeCircleImage(video::IVideoDriver* driver,int width, f32 radius, video::SColor col)
{


    //std::cout<<"Generating Static Texture \n";

    video::IImage*     img = driver->createImage(irr::video::ECF_A8R8G8B8,core::dimension2d<u32>(width,width));

    srand(45325);
    video::SColor color=col;
    int r;

        for(int i=0;i<width;i++)
            for(int j=0;j<width;j++)
                {
                        f32 d = sqrt((((f32)width * 0.5)-j-0.5)*(((f32)width * 0.5)-j-0.5)+
                                (((f32)width * 0.5)-i-0.5)*(((f32)width * 0.5)-i-0.5));

                        //color.setRed(r);
                        //color.setGreen(r);
                        //color.setBlue(r);
                        if(d<radius)
                            color.setAlpha(255);
                        else if(d<radius+0.5)
                            color.setAlpha(128);
                        else if(d<radius+0.1)
                            color.setAlpha(64);
                        else
                            color.setAlpha(0);

                        img->setPixel(i,j,color);
                }
    return img;
}

void MakeCircleImages(video::IVideoDriver* driver)
{
    irr::video::IImage* cimg = makeCircleImage(driver,8,1.5,COLOR_ADD_NOT_SELECTED);
    small_circle_tex_add_not_selected = driver->addTexture(irr::io::path("a circle 0"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,1.5,COLOR_ADD_SELECTED);
    small_circle_tex_add_selected = driver->addTexture(irr::io::path("a circle 1"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,1.5,COLOR_SUB_NOT_SELECTED);
    small_circle_tex_sub_not_selected = driver->addTexture(irr::io::path("a circle 2"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,1.5,COLOR_SUB_SELECTED);
    small_circle_tex_sub_selected = driver->addTexture(irr::io::path("a circle 3"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,1.5,COLOR_RED_NOT_SELECTED);
    small_circle_tex_red_not_selected = driver->addTexture(irr::io::path("a circle 2"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,1.5,COLOR_RED_SELECTED);
    small_circle_tex_red_selected = driver->addTexture(irr::io::path("a circle 3"), cimg);
    cimg->drop();

    //==============

    cimg = makeCircleImage(driver,8,2.7,COLOR_ADD_NOT_SELECTED);
    med_circle_tex_add_not_selected = driver->addTexture(irr::io::path("a circle 0"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,2.7,COLOR_ADD_SELECTED);
    med_circle_tex_add_selected = driver->addTexture(irr::io::path("a circle 1"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,2.7,COLOR_SUB_NOT_SELECTED);
    med_circle_tex_sub_not_selected = driver->addTexture(irr::io::path("a circle 2"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,2.7,COLOR_SUB_SELECTED);
    med_circle_tex_sub_selected = driver->addTexture(irr::io::path("a circle 3"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,2.7,COLOR_RED_NOT_SELECTED);
    med_circle_tex_red_not_selected = driver->addTexture(irr::io::path("a circle 2"), cimg);
    cimg->drop();

    cimg = makeCircleImage(driver,8,2.7,COLOR_RED_SELECTED);
    med_circle_tex_red_selected = driver->addTexture(irr::io::path("a circle 3"), cimg);
    cimg->drop();
}


void do_test_loop(polyfold pf, int f_i, int p_i, LineHolder& graph, LineHolder& graph2)
{
    if(f_i >= pf.faces.size() || p_i >= pf.faces[f_i].loops.size())
        return;

   poly_face* f = &pf.faces[f_i];
   bool bIn;
   bool bOutOfZone;

   if(f->loops[p_i].vertices.size()==0)
    return;

    core::matrix4 R = f->get2Dmat();

    std::vector<int> tempv = f->loops[p_i].vertices;
    tempv.push_back(tempv[0]);

    for(int i=0; i < tempv.size()-1; i++)
       {

        core::vector3df v0=pf.vertices[tempv[i]].V;
        core::vector3df v1=pf.vertices[tempv[i+1]].V;

       // std::cout<<v0.X<<" "<<v0.Z<<" to "<<v1.X<<" "<<v1.Z<<"\n";
        R.rotateVect(v0);
        R.rotateVect(v1);
        v0.Y=0;
        v1.Y=0;
            {
                graph.lines.push_back(core::line3df(v0,v1));
            }

        }
    std::vector<core::vector3df> test_points;

    //-128.001,45.2558,-445.256
    core::vector3df av = core::vector3df(53.9966,0,64.0015);
    //R.rotateVect(av);
    //test_points.push_back(av);

    f32 s = 64;

    //if(false)
    for(int i: f->loops[p_i].vertices)
    {
     core::vector3df v0= pf.vertices[i].V;
     test_points.push_back(v0);
     test_points.push_back(v0+core::vector3df(s,0,0));
     test_points.push_back(v0+core::vector3df(-s,0,0));
     test_points.push_back(v0+core::vector3df(0,0,s));
     test_points.push_back(v0+core::vector3df(0,0,-s));
    }


    for(core::vector3df v : test_points)
    {
        core::vector3df V = v;
        R.rotateVect(V);
        f32 small_number = 0.01;

        if(V.X < f->loops[p_i].min_x - small_number || V.X > f->loops[p_i].max_x + small_number ||
            V.Z < f->loops[p_i].min_z - small_number || V.Z > f->loops[p_i].max_z + small_number)
            {
            bOutOfZone= true;
            bIn = false;
            }

        if(!bOutOfZone)
        {
            if(pf.is_closed_loop(f_i,p_i))
                bIn = (pf.left_right_test(f_i, p_i, V.X,V.Z)==1);
            else
                std::cout<<"loop not closed\n";
        }
        V.Y=0;
        if(bIn)
            graph.points.push_back(V);
        else
            graph2.points.push_back(V);
    }
}

bool  geometry_scene::WriteTextures(std::string fname)
{
     ofstream wf(fname,ios::out | ios::binary);

    if(!wf)
    {
        cout<<"Cannot open file\n";
        return false;
    }

    std::vector<video::ITexture*> textures_used;
    std::vector<std::wstring> texture_paths;

    for(int i=1;i<this->elements.size();i++)
	{
        for(int f_i =0 ;f_i<this->elements[i].brush.faces.size(); f_i++)
        {
           // std::cout<<this->elements[i].brush.faces.size()<<" / "<<this->elements[i].geometry.faces.size()<<"\n";
            video::ITexture* tex_j = this->driver->getTexture(this->elements[i].brush.faces[f_i].texture_name.c_str());

            bool b=false;
            //for(video::ITexture* tex_i : textures_used)
            for(int j=0;j<textures_used.size();j++)
            {
                if(tex_j == textures_used[j])
                {
                    this->elements[i].brush.faces[f_i].texture_index = j;
                    b=true;
                }
            }
            if(!b)
            {
                textures_used.push_back(tex_j);
                //texture_paths.push_back(std::string(this->elements[i].brush.faces[f_i].texture_name.c_str()));
                //std::cout<<this->elements[i].brush.faces[f_i].texture_name.c_str()<<"\n";
                texture_paths.push_back(this->elements[i].brush.faces[f_i].texture_name.c_str());
                this->elements[i].brush.faces[f_i].texture_index = texture_paths.size()-1;
                //std::cout<<this->elements[i].brush.faces[f_i].texture_name.c_str()<<"\n";
            }
        }
	}

	wf<<textures_used.size()<<"\n";

	for(int i=0;i<textures_used.size();i++)
    {
        std::string str(texture_paths[i].begin(),texture_paths[i].end());
        wf<<str.c_str()<<"\n";
    }

    wf.close();
    return true;
}

bool geometry_scene::ReadTextures(io::path fname, std::vector<std::wstring>& texture_paths)
{
    ifstream rf(fname.c_str(),ios::in | ios::binary);

    if(!rf)
    {
        cout<<"Cannot open file\n";
        return false;
    }

    std::string line;

    int n_textures;
    getline(rf,line);
    n_textures = core::strtoul10(line.c_str());

    std::cout<<n_textures<<" textures used:\n";

    for(int i=0;i<n_textures;i++)
    {
        getline(rf,line);
        std::wstring str(line.begin(),line.end());
        texture_paths.push_back(str.c_str());
    }

    rf.close();
    return true;
}


bool geometry_scene::WriteSceneNodesToFile(std::string fname)
{
    ofstream wf(fname,ios::out | ios::binary);

    if(!wf)
    {
        cout<<"Cannot open file\n";
        return false;
    }

    wf<<"38\n";

    int e = this->scene_nodes.size();
    wf.write((char*)&e,sizeof(int));

    for(Reflected_SceneNode* node : this->scene_nodes)
    {
        node->preEdit();
        reflect::TypeDescriptor_Struct* td = node->GetDynamicReflection();
        wf<<node->GetDynamicReflection()->name<<'\0';
        while(td)
        {
            //td->dump(node,0);
            td->serialize(wf,node);
            td = td->inherited_type;
        }
    }

    wf.close();
    if(!wf.good())
    {
        cout<<"error writing file\n";
        return false;
    }
    return true;

}
bool geometry_scene::ReadSceneNodesFromFile(io::path fname)
{
     ifstream rf(fname.c_str(),ios::in | ios::binary);

    if(!rf)
    {
        cout<<"Cannot open file\n";
        return false;
    }
    std::string line;

    int magic;
    getline(rf,line);
    magic = core::strtoul10(line.c_str());

    if(magic != 38)
    {
        std::cout<<fname.c_str()<<" is not a valid node file\n";
        rf.close();
        return false;
    }

    for(Reflected_SceneNode* node : this->scene_nodes)
    {
        node->remove();
        node->drop();
    }
    this->scene_nodes.clear();

    int n_nodes;
    rf.read((char*)&n_nodes,sizeof(int));

    std::cout<<"reading "<<n_nodes<<" nodes\n";
    for(int i=0;i<n_nodes;i++)
    {
        getline(rf,line,'\0');
        reflect::TypeDescriptor_Struct* typeDescriptor = GetNodeTypeDescriptorByName(line);
        if(typeDescriptor)
        {
            //std::cout<<typeDescriptor->name<<"\n";
            //Reflected_SceneNode* new_node = typeDescriptor::create_self();
            Reflected_SceneNode* new_node = CreateNodeByTypeName(typeDescriptor->name,this->smgr);
            if(new_node)
            {
                reflect::TypeDescriptor_Struct* td = typeDescriptor;
                while(td)
                {
                    td->deserialize(rf,new_node);
                    //td->dump(new_node,0);
                    td = td->inherited_type;
                }
                new_node->postEdit();
                this->scene_nodes.push_back(new_node);
            }
            else
                {
                    std::cout<<"*could not create node*\n";
                    rf.close();
                    return false;
                }
        }
        else
        {
            std::cout<<"*could not find type descriptor*\n";
            rf.close();
            return false;
        }
    }

    rf.close();
    if(!rf.good())
    {
        cout<<"error reading file\n";
        return false;
    }
    return true;
}

bool geometry_scene::Write2(std::string fname)
{
    ofstream wf(fname,ios::out | ios::binary);

    if(!wf)
    {
        cout<<"Cannot open file\n";
        return false;
    }

    reflect::TypeDescriptor_Struct* typeDescriptor = (reflect::TypeDescriptor_Struct*)reflect::TypeResolver<geometry_scene>::get();

    typeDescriptor->serialize(wf,this);

    wf.close();
    if(!wf.good())
    {
        cout<<"error writing file\n";
        return false;
    }
    return true;
}

bool geometry_scene::Read2(io::path fname,io::path tex_fname)
{
     ifstream rf(fname.c_str(),ios::in | ios::binary);

    if(!rf)
    {
        cout<<"Cannot open file\n";
        return false;
    }

    std::vector<std::wstring> texture_paths;
    if(ReadTextures(tex_fname,texture_paths)==false)
        return false;

    reflect::TypeDescriptor_Struct* typeDescriptor = (reflect::TypeDescriptor_Struct*)reflect::TypeResolver<geometry_scene>::get();

    typeDescriptor->deserialize(rf,this);

    //typeDescriptor->dump(this,0);

    for(int i=1;i<elements.size();i++)
        for(poly_face& face : elements[i].brush.faces)
        {
            if(face.texture_index < texture_paths.size())
                    face.texture_name = texture_paths[face.texture_index].c_str();
                else
                    face.texture_name="wall.bmp";
        }


    rf.close();
    if(!rf.good())
    {
        cout<<"error reading file\n";
        return false;
    }



    for(int i=0;i<this->elements.size();i++)
    {

        this->elements[i].brush.reduce_edges_vertices2();
        //this->elements[i].brush.recalc_bbox_and_loops();

        this->elements[i].brush.recalc_bbox();

        for(int f_i=0;f_i<this->elements[i].brush.faces.size();f_i++)
        {
            for(int p_i=0;p_i<this->elements[i].brush.faces[f_i].loops.size();p_i++)
                this->elements[i].brush.calc_loop_bbox(f_i,p_i);
        }

        for(poly_face &f :this->elements[i].brush.faces)
        {
            this->elements[i].brush.calc_center(f);
            //f.texture_name="wall.bmp";
        }
    }

    std::cout<<"Loaded Geometry\n\n";

    return true;
}

bool geometry_scene::ExportFinalMesh(std::string fname)
{
    io::IFileSystem* fs = this->smgr->getFileSystem();
    io::IWriteFile* io = fs->createAndWriteFile(fname.c_str());

    scene::IMeshWriter* mesh_writer = smgr->createMeshWriter(scene::EMWT_IRR_MESH);

//    mesh_writer->writeMesh(io,this->getFinalMeshNode()->getMesh());
}
