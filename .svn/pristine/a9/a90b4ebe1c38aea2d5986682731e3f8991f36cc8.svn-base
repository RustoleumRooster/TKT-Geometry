#include <irrlicht.h>
#include <iostream>
#include "csg_classes.h"
#include "geometry_scene.h"
#include "edit_env.h"
#include "tolerances.h"
#include "texture_picker.h"
#include "BufferManager.h"
#include "material_groups.h"

using namespace irr;

geometry_scene::geometry_scene(scene::ISceneManager* smgr_,video::IVideoDriver* driver_,MyEventReceiver* receiver, video::E_MATERIAL_TYPE base_material_type_, video::E_MATERIAL_TYPE special_material_type_)
{
    this->smgr = smgr_;
    this->driver = driver_;
    this->base_material_type = base_material_type_;
    this->special_material_type = special_material_type_;
    this->event_receiver = receiver;
    event_receiver->Register(this);
    geo_element red;
    red.brush= make_poly_cube(256,256,256);
    red.type=GEO_RED;
    elements.push_back(red);

    this->edit_meshnode_interface.init(smgr,driver,event_receiver,base_material_type,special_material_type);
    this->final_meshnode_interface.init(smgr,driver,event_receiver,base_material_type,special_material_type);
}

geometry_scene::~geometry_scene()
{
    event_receiver->UnRegister(this);
}

void geometry_scene::setMaterialGroupsBase(Material_Groups_Base* base)
{
    material_groups_base = base;
}

Material_Groups_Base* geometry_scene::getMaterialGroupsBase()
{
    return material_groups_base;
}

void geometry_scene::setTexturePickerBase(TexturePicker_Base* texp)
{
    texture_picker_base = texp;
}

TexturePicker_Base* geometry_scene::getTexturePickerBase()
{
    return texture_picker_base;
}

bool geometry_scene::OnEvent(const SEvent& event)
{
    if(event.EventType == irr::EET_USER_EVENT)
    {
        switch(event.UserEvent.UserData1)
        {
            case USER_EVENT_TEXTURE_SELECTED:
            {
                if(this->selected_faces.size()>0)
                    TextureToSelectedFaces();
            }
            break;
        }
        return true;
    }
    return false;
}

void geometry_scene::setSelectedFaces_ShiftAdd(int new_sel)
{
    bool b = false;
    std::vector<int> selection;

    for(int f_i : getSelectedFaces())
    {
        if(f_i == new_sel)
        {
            b = true;
        }
        else
            selection.push_back(f_i);
    }

    if(!b)
        selection.push_back(new_sel);

    setSelectedFaces(selection);
}

void geometry_scene::setSelectedNodes_ShiftAdd(int new_sel)
{
    bool b = false;
    std::vector<int> selection;

    for(int f_i : getSelectedNodes())
    {
        if(f_i == new_sel)
        {
            b = true;
        }
        else
            selection.push_back(f_i);
    }

    if(!b)
        selection.push_back(new_sel);

    setSelectedNodes(selection);
}

void geometry_scene::setSelectedFaces(std::vector<int> selection)
{
    if(this->getMeshNode() == NULL || IsEditNode() == false)
        return;

    if(selection.size() == 1 && selected_faces.size()==1 && selection[0] == selected_faces[0])
        selection.clear();

    polyfold* pf = get_total_geometry();

    for(int f_i=0;f_i<pf->faces.size();f_i++)
    {
        if(pf->faces[f_i].loops.size()>0)
        {
            int buffer_index = edit_meshnode_interface.get_buffer_index_by_face(f_i);
            scene::SMeshBuffer* buffer = (scene::SMeshBuffer*)this->getMeshNode()->getMesh()->getMeshBuffer(buffer_index);
            bool b = false;
            for(int f_j : selection)
                if(f_i == f_j)
                    b=true;

            if(b)
            {

                buffer->Material.MaterialType = special_material_type;
                buffer->Material.Lighting=false;
            }
            else
            {
                material_groups_base->apply_material_to_buffer(buffer,pf->faces[f_i].material_group);
                buffer->Material.Lighting=b_dynamic_light;
            }
        }
    }

    this->getMeshNode()->copyMaterials();

    this->selected_faces = selection;

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_SELECTION_CHANGED;
    event_receiver->OnEvent(event);
}

void geometry_scene::setSelectedNodes(std::vector<int> selection)
{
    auto IsInSelection = [&](int ii) -> bool{
        bool b=false;
        for(int j : selection)
        {
            if(ii==j)
            {
                b=true;
            }
        }
        return b;
    };

    for(int i=0; i<this->scene_nodes.size();i++)
    {
        if(IsInSelection(i))
        {
            this->scene_nodes[i]->Select();
        }
        else
        {
            this->scene_nodes[i]->UnSelect();
        }
    }

    this->selected_scene_nodes = selection;

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_SELECTION_CHANGED;
    event_receiver->OnEvent(event);
}

std::vector<int> geometry_scene::getSurfaceFromFace(int b_i)
{
    int brush_j = get_total_geometry()->faces[b_i].original_brush;
    int face_j = get_total_geometry()->faces[b_i].original_face;

    poly_face* f = &elements[brush_j].brush.faces[face_j];
    std::vector<int> sel;
    int sg = f->surface_group;
    for(int i=0; i<get_total_geometry()->faces.size(); i++)
    {
        if(get_total_geometry()->faces[i].original_brush == brush_j)
        {
            int face_i = get_total_geometry()->faces[i].original_face;

            if(elements[brush_j].brush.faces[face_i].surface_group == sg &&
               elements[brush_j].geometry.faces[face_i].loops.size() > 0)
                sel.push_back(i);
        }
    }
    return sel;

}
void geometry_scene::selectSurfaceGroup()
{
    if(getSelectedFaces().size()>0)
    {
        std::vector<int> sel = getSurfaceFromFace(getSelectedFaces()[0]);
        setSelectedFaces(sel);
    }
}

std::vector<int> geometry_scene::getSelectedFaces()
{
    return this->selected_faces;
}

std::vector<int> geometry_scene::getSelectedNodes()
{
    return this->selected_scene_nodes;
}

std::vector<int> geometry_scene::getBrushSelection()
{
    return this->selected_brushes;
}

void geometry_scene::setBrushSelection(std::vector<int> new_sel)
{
    this->selected_brushes=new_sel;

    for(int i=0; i<elements.size(); i++)
    {
        this->elements[i].bSelected=false;
    }

    for(int i: new_sel)
        this->elements[i].bSelected=true;

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_SELECTION_CHANGED;
    event_receiver->OnEvent(event);
}

void geometry_scene::setBrushSelection_ShiftAdd(int new_sel)
{
    bool b = false;
    std::vector<int> selection;

    for(int f_i : getBrushSelection())
    {
        if(f_i == new_sel)
        {
            b = true;
        }
        else
            selection.push_back(f_i);
    }

    if(!b)
        selection.push_back(new_sel);

    setBrushSelection(selection);

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_SELECTION_CHANGED;
    event_receiver->OnEvent(event);
}

core::vector3df geometry_scene::getSelectedVertex()
{
    bool bSelectedVertex=false;
    core::vector3df ret = core::vector3df(0,0,0);

    for(int p_i :this->selected_brushes)
    {
        if(this->selected==p_i && this->elements[p_i].selected_vertex< this->elements[p_i].brush.vertices.size())
        {
            bSelectedVertex=true;
            ret=this->elements[p_i].brush.vertices[ this->elements[p_i].selected_vertex].V;
        }
    }
    if(!bSelectedVertex && this->elements.size()>0)
    {
        ret=this->elements[this->getBrushSelection()[0]].brush.vertices[0].V;
    }
    return ret;
}

void geo_element::draw_brush(video::IVideoDriver* driver, const video::SMaterial material)
{
    video::SColor col = this->getColor();

    for(int i =0; i<this->brush.edges.size(); i++)
    {
        if(this->brush.edges[i].topo_group != -1)
            driver->draw3DLine(this->brush.getVertex(i,0).V,this->brush.getVertex(i,1).V,col);
        //driver->draw3DLine(this->brush.getVertex(i,0).V,this->brush.getVertex(i,1).V,video::SColor(128,128,128,128));
    }
}
video::SColor geo_element::getColor()
{
   // video::SColor col = video::SColor(128,128,128,128);

    if(this->bSelected==false)
    {
        if(this->type == GEO_ADD)
            return COLOR_ADD_NOT_SELECTED;
        else if(this->type == GEO_SUBTRACT)
            return COLOR_SUB_NOT_SELECTED;
        else if(this->type == GEO_SEMISOLID)
            return COLOR_SEMI_NOT_SELECTED;
        else if(this->type == GEO_RED)
            return COLOR_RED_NOT_SELECTED;
    }
    else if(this->bSelected==true)
    {
        if(this->type == GEO_ADD)
            return COLOR_ADD_SELECTED;
        else if(this->type == GEO_SUBTRACT)
            return COLOR_SUB_SELECTED;
        else if(this->type == GEO_SEMISOLID)
            return COLOR_SEMI_SELECTED;
        else if(this->type == GEO_RED)
            return COLOR_RED_SELECTED;
    }

    return video::SColor(128,128,128,128);
}
void geo_element::draw_geometry(video::IVideoDriver* driver, const video::SMaterial material)
{
    //driver->setTransform(video::ETS_WORLD, core::IdentityMatrix);
    //driver->setMaterial(material);
    //video::SColor col = video::SColor(255,38,128,1155);
    video::SColor col = video::SColor(255,38,128,155);

    for(int i =0; i<this->geometry.edges.size(); i++)
    {
        if(this->geometry.edges[i].topo_group != -1)
            driver->draw3DLine(this->geometry.getVertex(i,0).V,this->geometry.getVertex(i,1).V,col);
    }
}

polyfold* geometry_scene::get_total_geometry()
{
    return &this->total_geometry;
}

void geometry_scene::build_total_geometry()
{
    polyfold combo;

    for(int i=1; i<this->elements.size(); i++)
    {
        add_pfold(this->elements[i].geometry,combo);
    }

    std::cout<<"total geometry created "<<this->elements.size()<<" elements\n";

    this->total_geometry = combo;

    if(this->base_type == GEO_EMPTY)
        this->total_geometry.topology = TOP_CONVEX;
    else if(this->base_type == GEO_SOLID)
        this->total_geometry.topology = TOP_CONCAVE;
}

bool geo_element::has_geometry()
{
    return this->geometry.edges.size()>2;
}



void geometry_scene::add(polyfold pf)
{
    //this->WriteGeometryToFile("backup.pol");

    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_ADD;

    {
        video::ITexture* tex = texture_picker_base->getCurrentTexture();
        io::path path = tex->getName();

        for(poly_face& face : geo.brush.faces)
            face.texture_name = path;
    }

    this->elements.push_back(geo);

    if(this->progressive_build)
        this->rebuild_geometry(true);
}


void geometry_scene::add_plane(polyfold pf)
{
    //this->WriteGeometryToFile("backup.pol");

    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_SEMISOLID;

    {
        video::ITexture* tex = texture_picker_base->getCurrentTexture();
        io::path path = tex->getName();

        for(poly_face& face : geo.brush.faces)
            face.texture_name = path;
    }

    for(poly_face& face : geo.brush.faces)
            face.material_group = 1;

    this->elements.push_back(geo);

    if(this->progressive_build)
        this->rebuild_geometry(true);
}

void geometry_scene::add_semisolid(polyfold pf)
{
    //this->WriteGeometryToFile("backup.pol");

    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_SEMISOLID;

    {
        video::ITexture* tex = texture_picker_base->getCurrentTexture();
        io::path path = tex->getName();

        for(poly_face& face : geo.brush.faces)
            face.texture_name = path;
    }

    this->elements.push_back(geo);

    if(this->progressive_build)
        this->rebuild_geometry(true);
}

void geometry_scene::subtract(polyfold pf)
{
    //this->WriteGeometryToFile("backup.pol");

    geo_element geo;
    geo.brush = pf;
    geo.type = GEO_SUBTRACT;

    {
        video::ITexture* tex = texture_picker_base->getCurrentTexture();
        io::path path = tex->getName();

        for(poly_face& face : geo.brush.faces)
            face.texture_name = path;
    }

    this->elements.push_back(geo);

    if(this->progressive_build)
        this->rebuild_geometry(true);
}

void geometry_scene::set_type(int t)
{
    this->base_type=t;
}

void geometry_scene::TextureToSelectedFaces()
{
    if(!getTexturePickerBase() || !this->getMeshNode() || !IsEditNode())
        return;

    for(int i: this->selected_faces)
    {
        int brush_i = this->get_total_geometry()->faces[i].original_brush;
        int face_i = this->get_total_geometry()->faces[i].original_face;

        this->elements[brush_i].brush.faces[face_i].texture_name=core::stringw(texture_picker_base->getCurrentTexture()->getName().getPath());
        this->elements[brush_i].geometry.faces[face_i].texture_name=texture_picker_base->getCurrentTexture()->getName().getPath();
    }

    for(int i=0; i<this->getMeshNode()->getMesh()->getMeshBufferCount();i++)
    {
        bool b=false;
        for(int j : selected_faces)
        {
            int buffer_index = edit_meshnode_interface.get_buffer_index_by_face(j);
            if(i==buffer_index)
                b=true;
        }
        if(b)
            getMeshNode()->SetFaceTexture(i,texture_picker_base->getCurrentTexture());
    }
}

poly_face* geometry_scene::get_original_brush_face(int f_i)
{
    int brush_j = total_geometry.faces[f_i].original_brush;
    int face_j =  total_geometry.faces[f_i].original_face;

    poly_face* f = &elements[brush_j].brush.faces[face_j];

    return f;
}


polyfold* geometry_scene::get_original_brush(int f_i)
{
    int brush_j =  total_geometry.faces[f_i].original_brush;

    polyfold* pf = &elements[brush_j].brush;

    return pf;
}

polyfold geometry_scene::get_intersecting_geometry(polyfold pf)
{
    polyfold combo;
    std::vector<int> touched_brushes;
    int num=0;
    for(int j=1; j<this->elements.size(); j++)
    {
        if(this->elements[j].has_geometry() &&
         BoxIntersectsWithBox(pf.bbox,this->elements[j].brush.bbox))
        {
            for(int f_j =0; f_j<this->elements[j].geometry.faces.size(); f_j++)
            {
                this->elements[j].geometry.faces[f_j].original_brush=j;
                this->elements[j].geometry.faces[f_j].original_face=this->elements[j].geometry.faces[f_j].surface_group;
            }
            touched_brushes.push_back(j);

            add_pfold(this->elements[j].geometry,combo);
            num++;
        }
    }
    return combo;
}

void geometry_scene::rebuild_geometry(bool only_build_new_geometry)
{
    std::cout<<"rebuild...\n";
    LineHolder nograph;

    polyfold no_poly;

    int build_start;

    if(only_build_new_geometry)
        build_start = this->build_progress+1;
    else
        build_start = 1;

    for(int i=build_start; i<this->elements.size(); i++)
        this->elements[i].geometry = no_poly;


    for(int i=build_start; i<this->elements.size(); i++)
    {
        if(!(this->elements[i].type == GEO_SUBTRACT || this->elements[i].type == GEO_ADD))
            continue;

        polyfold combo;
        std::vector<int> touched_brushes;
        int num=0;
        for(int j=1; j<i; j++)
        {
            if  (this->elements[j].has_geometry() &&
                (this->elements[j].type == GEO_SUBTRACT || this->elements[j].type == GEO_ADD) &&
                BoxIntersectsWithBox(this->elements[i].brush.bbox,this->elements[j].brush.bbox))
            {
                for(int f_j =0; f_j<this->elements[j].geometry.faces.size(); f_j++)
                {
                    this->elements[j].geometry.faces[f_j].original_brush=j;
                    this->elements[j].geometry.faces[f_j].original_face=this->elements[j].geometry.faces[f_j].surface_group;
                }
                touched_brushes.push_back(j);

                add_pfold(this->elements[j].geometry,combo);
                num++;
            }
        }

        std::cout<<i<<": intersects "<<num<<" other elements\n";

        if(this->base_type == GEO_EMPTY)
            combo.topology = TOP_CONVEX;
        else if(this->base_type == GEO_SOLID)
            combo.topology = TOP_CONCAVE;

        clip_results results;
        results.n_intersections=0;

        if(num >=0)
        {
            if(this->elements[i].type == GEO_ADD)
            {
                this->elements[i].brush.make_convex();
                this->elements[i].geometry = this->elements[i].brush;

                clip_poly(this->elements[i].geometry,combo,GEO_ADD,this->base_type, results, nograph);
            }
            else if(this->elements[i].type == GEO_SUBTRACT)
            {
                this->elements[i].brush.make_concave();
                this->elements[i].geometry = this->elements[i].brush;

                clip_poly(this->elements[i].geometry,combo,GEO_SUBTRACT,this->base_type, results, nograph);
            }
        }

        if(num==0 || results.n_intersections == 0)
        {
            if ((this->elements[i].type==GEO_ADD && this->base_type == GEO_EMPTY) ||
                    (this->elements[i].type==GEO_SUBTRACT && this->base_type == GEO_SOLID))
            {

            }
            else
            {
                this->elements[i].geometry = no_poly;
            }
        }

        if(results.n_intersections >0)
        {
            results.n_intersections=0;

            for(int j: touched_brushes)
            {
                this->elements[j].geometry.faces.clear();
                this->elements[j].geometry.edges.clear();
                this->elements[j].geometry.vertices = combo.vertices;

                for(int jj=0;jj<combo.faces.size();jj++)
                {
                    if(combo.faces[jj].original_brush==j)
                    {
                        this->elements[j].geometry.faces.push_back(combo.faces[jj]);
                    }
                }

                for(int jj=0;jj<this->elements[j].geometry.faces.size();jj++)
                {
                    this->elements[j].geometry.faces[jj].surface_group = this->elements[j].geometry.faces[jj].original_face;
                }

                this->elements[j].geometry.reduce_edges_vertices2();
            }
        }
    } //add, subtract brushes

    for(int i=build_start; i<this->elements.size(); i++)
    {
        if(this->elements[i].type != GEO_SEMISOLID)
            continue;

        polyfold combo;
        std::vector<int> touched_brushes;
        int num=0;
        for(int j=1; j<i; j++)
        {
            if  (this->elements[j].has_geometry() &&
                (this->elements[j].type == GEO_SUBTRACT || this->elements[j].type == GEO_ADD) &&
                BoxIntersectsWithBox(this->elements[i].brush.bbox,this->elements[j].brush.bbox))
            {
                for(int f_j =0; f_j<this->elements[j].geometry.faces.size(); f_j++)
                {
                    this->elements[j].geometry.faces[f_j].original_brush=j;
                    this->elements[j].geometry.faces[f_j].original_face=this->elements[j].geometry.faces[f_j].surface_group;
                }
                touched_brushes.push_back(j);

                add_pfold(this->elements[j].geometry,combo);
                num++;
            }
        }

        std::cout<<i<<": intersects "<<num<<" other elements (plane geometry) \n";

        if(this->base_type == GEO_EMPTY)
            combo.topology = TOP_CONVEX;
        else if(this->base_type == GEO_SOLID)
            combo.topology = TOP_CONCAVE;

        clip_results results;
        results.n_intersections=0;

        if(num >=0)
        {
            if(this->elements[i].type == GEO_SEMISOLID)
            {
                if(this->elements[i].brush.topology == TOP_CONVEX ||
                   this->elements[i].brush.topology == TOP_CONCAVE)
                {
                    this->elements[i].brush.make_convex();
                    this->elements[i].geometry = this->elements[i].brush;

                    clip_poly_single(this->elements[i].geometry,combo,GEO_ADD,this->base_type, results, nograph);
                }
                else //Neither Convex or Concave, ie plane geometry
                {
                    this->elements[i].geometry = this->elements[i].brush;
                    clip_poly_single(this->elements[i].geometry,combo,GEO_ADD,this->base_type, results, nograph);
                }
            }
        }

        if(num==0 || results.n_intersections == 0)
        {
            if (this->elements[i].type==GEO_SEMISOLID && this->base_type == GEO_EMPTY)
            {

            }
            else
            {
                this->elements[i].geometry = no_poly;
            }
        }
    }// semisolid brushes

    for(int i=1; i<this->elements.size(); i++)
    {
        for(int j=0;j<this->elements[i].brush.faces.size() && j<this->elements[i].geometry.faces.size();j++)
        {
            this->elements[i].geometry.faces[j].texture_name = this->elements[i].brush.faces[j].texture_name;
            this->elements[i].geometry.faces[j].original_brush=i;
            this->elements[i].geometry.faces[j].original_face=j;
        }
    }

    this->build_progress = this->elements.size()-1;

    this->build_total_geometry();

    edit_meshnode_interface.generate_mesh_node(this);
    final_meshnode_interface.generate_mesh_node(this);

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_GEOMETRY_REBUILT;
    event_receiver->OnEvent(event);
}

void geometry_scene::buildSceneGraph(bool finalMesh, bool addObjects, bool addLights, bool finalscene)
{
    core::list<scene::ISceneNode*> child_list = smgr->getRootSceneNode()->getChildren();

    if(my_MeshNode)
        my_MeshNode->drop();

    core::list<scene::ISceneNode*>::Iterator it = child_list.begin();
    for(;it != child_list.end();++it)
    {
        int id = (*it)->getID();
        if( (*it)->getType() != scene::ESNT_CAMERA )
            smgr->getRootSceneNode()->removeChild(*it);
    }

    for(Reflected_SceneNode* node : this->scene_nodes)
    {
        node->onClear();

        if(addObjects)
        {
            node->setParent(smgr->getRootSceneNode());
            node->setUnlit(!addLights);
        }

        if (finalscene ||
           (addLights && node->getType() == ESNT_LIGHT))
            node->addSelfToScene(smgr);
    }

    polyfold* pf = get_total_geometry();

    if(finalMesh)
    {
        b_isEditNode = false;
        this->my_MeshNode = final_meshnode_interface.addMeshSceneNode(smgr,this);

        for(int i = 0; i< my_MeshNode->getMesh()->getMeshBufferCount(); i++)
        {
            scene::SMeshBuffer* buffer = (scene::SMeshBuffer*)my_MeshNode->getMesh()->getMeshBuffer(i);
            int f_i = final_meshnode_interface.get_material_reference_face(i);
            material_groups_base->apply_material_to_buffer(buffer,pf->faces[f_i].material_group);
        }
    }
    else
    {
        b_isEditNode = true;
        this->my_MeshNode = edit_meshnode_interface.addMeshSceneNode(smgr,this);

        //for(int i = 0; i< my_MeshNode->getMesh()->getMeshBufferCount(); i++)
        for(int f_i = 0; f_i< pf->faces.size(); f_i++)
        {
            if(pf->faces[f_i].loops.size() >0)
            {

                MeshBuffer_Chunk chunk = edit_meshnode_interface.get_mesh_buffer_by_face(f_i);

                scene::SMeshBuffer* buffer = (scene::SMeshBuffer*)chunk.buffer;
                material_groups_base->apply_material_to_buffer(buffer,pf->faces[f_i].material_group);
            }
        }
    }

    if(addLights)
    {
        this->my_MeshNode->setMaterialFlag(video::EMF_LIGHTING,false);
        //this->my_MeshNode->setMaterialFlag(video::EMF_LIGHTING,true);
        b_dynamic_light = true;
    }
    else
    {
        this->my_MeshNode->setMaterialFlag(video::EMF_LIGHTING,false);
        b_dynamic_light = false;
    }

    this->my_MeshNode->getMesh()->setHardwareMappingHint(scene::EHM_STATIC);

    //my_MeshNode->setMaterialFlag(video::EMF_NORMALIZE_NORMALS,true);

    my_MeshNode->setVisible(true);

    //my_MeshNode->setDebugDataVisible(scene::EDS_NORMALS);
}

void geometry_scene::intersect_active_brush()
{
    polyfold cube = this->elements[0].brush;
    cube.make_convex();

    clip_results results;
    results.n_intersections=0;

    polyfold no_poly;
    polyfold pf2;
    LineHolder nograph;

    int num=0;
    for(int j=1; j<this->elements.size(); j++)
    {
        if(this->elements[j].has_geometry() &&
          (this->elements[j].type == GEO_SUBTRACT || this->elements[j].type == GEO_ADD) &&
          BoxIntersectsWithBox(cube.bbox,this->elements[j].brush.bbox))
        {
            add_pfold(this->elements[j].geometry,pf2);
            num++;
        }
    }

    clip_poly(cube,pf2,GEO_SUBTRACT,base_type, results,nograph);

    if(results.n_intersections==0)
    {
        this->elements[0].brush=pf2;
    }
    else
    {
        add_pfold(cube,pf2);
        pf2.remove_empty_faces();
        this->elements[0].brush=pf2;
        this->elements[0].brush.topology=TOP_CONVEX;
    }
}

void geometry_scene::clip_active_brush()
{
    polyfold cube = this->elements[0].brush;
    cube.make_concave();

    clip_results results;
    results.n_intersections=0;

    polyfold no_poly;
    polyfold pf2;
    LineHolder nograph;

    int num=0;
    for(int j=1; j<this->elements.size(); j++)
    {
        if(this->elements[j].has_geometry() &&
          (this->elements[j].type == GEO_SUBTRACT || this->elements[j].type == GEO_ADD) &&
           BoxIntersectsWithBox(cube.bbox,this->elements[j].brush.bbox))
        {
            add_pfold(this->elements[j].geometry,pf2);
            num++;
        }
    }

    clip_poly(cube,pf2,GEO_ADD,base_type, results,nograph);

    if(results.n_intersections==0)
    {
        this->elements[0].brush=cube;
    }
    else
    {
        add_pfold(cube,pf2);
        pf2.remove_empty_faces();
        this->elements[0].brush=pf2;
        this->elements[0].brush.topology=TOP_CONCAVE;
    }
}

void geometry_scene::copy_geometry_to_active_brush()
{
    polyfold pf;
    std::cout<<"copy\n";
    for(int i=1; i<this->elements.size(); i++)
    {
        bool b=false;
        for(int j:this->selected_brushes)
            if(j==i)
                b=true;

        if(b)
            add_pfold(this->elements[i].geometry,pf);
    }

    this->elements[0].brush = pf;
    this->elements[0].brush.topology = TOP_CONVEX;
}

void geometry_scene::clear_scene()
{
    std::cout<<"clearing scene... ";

    geo_element active_brush = this->elements[0];
    this->elements.clear();
    this->elements.push_back(active_brush);

    this->build_progress=0;

    this->selected_brushes.clear();
    this->selected_faces.clear();
    this->edit_mesh_buffer_faces.clear();

    if(this->getMeshNode())
    {
        this->getMeshNode()->remove();
    }

    for(Reflected_SceneNode* node : this->scene_nodes)
    {
        node->remove();
        node->drop();
    }
    this->scene_nodes.clear();

    this->rebuild_geometry();
}

void geometry_scene::delete_selected_brushes()
{
    std::vector<geo_element> new_elements;

    int removed=0;
    new_elements.push_back(this->elements[0]);
    for(int i=1; i<this->elements.size(); i++)
    {
        bool b=false;
        for(int j:this->selected_brushes)
            if(j==i)
                b=true;

        if(!b)
            new_elements.push_back(this->elements[i]);
        else
            removed++;
    }
    this->elements=new_elements;

    this->selected_brushes.clear();

    if(removed > 0)
    {
        std::cout<<"deleted "<<removed<<" elements\n";
    }
}

reflect::TypeDescriptor_Struct* geometry_scene::getChooseNodeType()
{
    return this->choose_reflected_node_base->getSelectedTypeDescriptor();
}

void geometry_scene::addSceneLight(core::vector3df pos)
{
    Reflected_SceneNode* a_light = new Reflected_LightSceneNode(smgr,-1,pos);
    a_light->preEdit();
    scene_nodes.push_back(a_light);
    if(b_dynamic_light)
        a_light->addSelfToScene(smgr);
}

void geometry_scene::addSceneSelectedSceneNodeType(core::vector3df pos)
{
    reflect::TypeDescriptor_Struct* typeDescriptor = choose_reflected_node_base->getSelectedTypeDescriptor();
    if(typeDescriptor)
    {
        Reflected_SceneNode* a_thing = CreateNodeByTypeName(typeDescriptor->name, smgr);
        if(a_thing)
        {
            std::cout<<"added a "<<typeDescriptor->name<<"\n";
            a_thing->setPosition(pos);
            a_thing->preEdit();
            scene_nodes.push_back(a_thing);
            //typeDescriptor->dump(a_thing,0);
        }
    }
}

void geometry_scene::deleteSelectedNodes()
{
    std::vector<Reflected_SceneNode*> new_nodes;
    int c=0;
    for(int i=0;i<scene_nodes.size();i++)
    {
        Reflected_SceneNode* node = scene_nodes[i];

        bool b=false;
        for(int j : getSelectedNodes())
            if(i==j)
                b=true;

        if(b)
        {
            c++;
            node->remove();
            node->drop();
        }
        else
            new_nodes.push_back(node);
    }
    std::cout<<"deleted "<<c<<" nodes\n";

    selected_scene_nodes = std::vector<int>{};

    scene_nodes = new_nodes;
}

std::vector<Reflected_SceneNode*> geometry_scene::getSceneNodes()
{
    return scene_nodes;
}

REFLECT_STRUCT_BEGIN(geo_element)
    REFLECT_STRUCT_MEMBER(type)
    REFLECT_STRUCT_MEMBER(brush)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(geometry_scene)
    REFLECT_STRUCT_MEMBER(base_type)
    REFLECT_STRUCT_MEMBER(elements)
REFLECT_STRUCT_END()
