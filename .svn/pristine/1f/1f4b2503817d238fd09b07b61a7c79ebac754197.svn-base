
#include <irrlicht.h>
#include <iostream>
#include "driverChoice.h"
#include "csg_classes.h"
#include "geometry_scene.h"
#include "CMeshSceneNode.h"
#include "edit_env.h"
#include "utils.h"
#include "CameraPanel.h"
#include "texture_picker.h"
#include "create_primitives.h"
#include "texture_adjust.h"
#include "node_properties.h"
#include "material_groups.h"
#include "Reflection.h"
#include "GUI_tools.h"
#include "vtoolbar.h"
#include "ex_gui_elements.h"

using namespace irr;
using namespace scene;

#ifdef _MSC_VER
#pragma comment(lib, "Irrlicht.lib")
#endif

core::matrix4 mView_;
core::matrix4 mProj_;

extern IrrlichtDevice* device = 0;
bool UseHighLevelShaders = true;
bool UseCgShaders = false;


extern geometry_scene* g_scene=NULL;


class MyShaderCallBack : public video::IShaderConstantSetCallBack
{
public:

	virtual void OnSetConstants(video::IMaterialRendererServices* services,
			s32 userData)
	{
		video::IVideoDriver* driver = services->getVideoDriver();

		// set inverted world matrix
		// if we are using highlevel shaders (the user can select this when
		// starting the program), we must set the constants by name.

		core::matrix4 invWorld = driver->getTransform(video::ETS_WORLD);
		//core::matrix4 invWorld = mWorld.makeInverse();

			services->setVertexShaderConstant("mInvWorld", invWorld.pointer(), 16);

		// set clip matrix

		core::matrix4 worldView = driver->getTransform(video::ETS_VIEW);
		worldView *= driver->getTransform(video::ETS_WORLD);
		services->setVertexShaderConstant("mWorldView", worldView.pointer(), 16);

		core::matrix4 Proj = driver->getTransform(video::ETS_PROJECTION);
        services->setVertexShaderConstant("mProj", Proj.pointer(), 16);

		core::matrix4 worldView2 = mView_;
		worldView2 *= driver->getTransform(video::ETS_WORLD);
		services->setVertexShaderConstant("mWorldView2", worldView2.pointer(), 16);

		core::matrix4 Proj2 = mProj_;
        services->setVertexShaderConstant("mProj2", Proj2.pointer(), 16);


		// set camera position

		core::vector3df pos = device->getSceneManager()->
			getActiveCamera()->getAbsolutePosition();
		//core::vector3df pos(3.0f,3.0f,3.0f);

			services->setVertexShaderConstant("mLightPos", reinterpret_cast<f32*>(&pos), 3);

		// set light color

		video::SColorf col(1.0f,1.0f,1.0f,0.0f);

			services->setVertexShaderConstant("mLightColor",					reinterpret_cast<f32*>(&col), 4);

		// set transposed world matrix

		core::matrix4 world = driver->getTransform(video::ETS_WORLD);
		world = world.getTransposed();


            services->setVertexShaderConstant("mTransWorld", world.pointer(), 16);

			// set texture, for textures you can use both an int and a float setPixelShaderConstant interfaces (You need it only for an OpenGL driver).
        s32 TextureLayerID = 0;

            services->setPixelShaderConstant("myTexture", &TextureLayerID, 1);

        TextureLayerID = 1;

            services->setPixelShaderConstant("myTexture2", &TextureLayerID, 1);

	}
};

class MyShaderCallBack2 : public video::IShaderConstantSetCallBack
{
public:

	virtual void OnSetConstants(video::IMaterialRendererServices* services,
			s32 userData)
	{
		video::IVideoDriver* driver = services->getVideoDriver();

		// set inverted world matrix
		// if we are using highlevel shaders (the user can select this when
		// starting the program), we must set the constants by name.

		//core::matrix4 invWorld = driver->getTransform(video::ETS_WORLD);
		//core::matrix4 invWorld = mWorld.makeInverse();

		//	services->setVertexShaderConstant("mInvWorld", invWorld.pointer(), 16);

		// set clip matrix

		core::matrix4 worldView = driver->getTransform(video::ETS_VIEW);
		worldView *= driver->getTransform(video::ETS_WORLD);
		services->setVertexShaderConstant("mWorldView", worldView.pointer(), 16);

		core::matrix4 Proj = driver->getTransform(video::ETS_PROJECTION);
        services->setVertexShaderConstant("mProj", Proj.pointer(), 16);
/*
		core::matrix4 worldView2 = mView_;
		worldView2 *= driver->getTransform(video::ETS_WORLD);
		services->setVertexShaderConstant("mWorldView2", worldView2.pointer(), 16);

		core::matrix4 Proj2 = mProj_;
        services->setVertexShaderConstant("mProj2", Proj2.pointer(), 16);


		// set camera position

		core::vector3df pos = device->getSceneManager()->
			getActiveCamera()->getAbsolutePosition();
		//core::vector3df pos(3.0f,3.0f,3.0f);

			services->setVertexShaderConstant("mLightPos", reinterpret_cast<f32*>(&pos), 3);

		// set light color

		video::SColorf col(1.0f,1.0f,1.0f,0.0f);

			services->setVertexShaderConstant("mLightColor",					reinterpret_cast<f32*>(&col), 4);

		// set transposed world matrix

		core::matrix4 world = driver->getTransform(video::ETS_WORLD);
		world = world.getTransposed();


            services->setVertexShaderConstant("mTransWorld", world.pointer(), 16);

			// set texture, for textures you can use both an int and a float setPixelShaderConstant interfaces (You need it only for an OpenGL driver).
*/

        s32 TextureLayerID = 0;

            services->setPixelShaderConstant("myTexture", &TextureLayerID, 1);

      //  TextureLayerID = 1;

     //       services->setPixelShaderConstant("myTexture2", &TextureLayerID, 1);

        core::matrix4 invWorldMat;
        driver->getTransform(video::ETS_WORLD).getInverse(invWorldMat);

         if(driver->getDynamicLightCount()>0)
         {

                video::SLight light;

                f32 lightPos[6];

                light = driver->getDynamicLight(0);
                invWorldMat.transformVect(light.Position);
                lightPos[0] = light.Position.X;
                lightPos[1] = light.Position.Y;
                lightPos[2] = light.Position.Z;

/*
                light = driver->getDynamicLight(1);
                invWorldMat.transformVect(light.Position);
                lightPos[3] = light.Position.X;
                lightPos[4] = light.Position.Y;
                lightPos[5] = light.Position.Z;*/
                //invWorldMat.transformVect(lightPos[1]);

                lightPos[0] = 1.0;
                lightPos[1] = 1.0;
                lightPos[2] = 1.0;

                f32 num = 1.0;


               // std::cout<<light.Position.X<<","<<light.Position.Y<<","<<light.Position.Z<<"\n";

                //services->setPixelShaderConstant("mLightPos",reinterpret_cast<f32*>(&num),1);
                services->setPixelShaderConstant("mLightPos",&num,1);
         }

        f32 num[5] = {1.0,1.0,1.0,1.0,1.0};
        //num[0] = 1.0;
        std::cout<<services->setPixelShaderConstant("mLightPos[5]",reinterpret_cast<f32*>(&num[0]),5)<<"\n";

	}
};

int main()
{
	// ask user for driver
	video::E_DRIVER_TYPE driverType=video::EDT_OPENGL;//driverChoiceConsole();
	if (driverType==video::EDT_COUNT)
		return 1;

    MyEventReceiver receiver;

	// create device
	//device = createDevice(driverType, core::dimension2d<u32>(640, 480));
	device = createDevice(driverType,core::dimension2d<u32>(1200, 680),16,false,false,false,&receiver);


	if (device == 0)
		return 1; // could not create selected driver.

	video::IVideoDriver* driver = device->getVideoDriver();
	scene::ISceneManager* smgr = device->getSceneManager();
	gui::IGUIEnvironment* gui = device->getGUIEnvironment();

	//GUI stuff
	//=================
	//
	gui::IGUIElement* main_panel = new gui::IGUIElement(gui::EGUIET_ELEMENT,gui,gui->getRootGUIElement(),-1,core::rect<s32>(core::position2d<s32>(0,0), core::dimension2d<u32>(900,680)));
	gui::IGUIContextMenu* menu = gui->addMenu(main_panel,GUI_ID_MAIN_MENU);
	gui::IGUIContextMenu* submenu;
	gui::IGUIContextMenu* submenu2;

	menu->addItem(L"File",-1,true,true);
	submenu = menu->getSubMenu(0);
    submenu->addItem(L"New Scene",GUI_ID_MENU_FILE_NEW,true,false);
    submenu->addItem(L"Open",GUI_ID_MENU_FILE_OPEN,true,false);
    submenu->addItem(L"Save As",GUI_ID_MENU_FILE_SAVE_AS,true,false);

	menu->addItem(L"Editor",-1,true,true);
	submenu = menu->getSubMenu(1);

	submenu->addItem(L"Grid Snap",-1,true,true);
	submenu2=submenu->getSubMenu(0);
	submenu2->addItem(L"2",GUI_ID_MENU_EDIT_SNAP_2,true,false,true);
	submenu2->addItem(L"4",GUI_ID_MENU_EDIT_SNAP_4,true,false,true);
	submenu2->addItem(L"8",GUI_ID_MENU_EDIT_SNAP_8,true,false,true);
	submenu2->addItem(L"16",GUI_ID_MENU_EDIT_SNAP_16,true,false,true);
	submenu2->setItemChecked(0,false);
	submenu2->setItemChecked(1,false);
	submenu2->setItemChecked(2,true);
	submenu2->setItemChecked(3,false);

    submenu->addItem(L"Rotate Snap",-1,true,true);
    submenu2=submenu->getSubMenu(1);
    submenu2->addItem(L"1.875",GUI_ID_MENU_EDIT_ROTATE_1875,true,false,true);
    submenu2->addItem(L"3.75",GUI_ID_MENU_EDIT_ROTATE_375,true,false,true);
    submenu2->addItem(L"7.5",GUI_ID_MENU_EDIT_ROTATE_75,true,false,true);
    submenu2->addItem(L"15",GUI_ID_MENU_EDIT_ROTATE_15,true,false,true);
    submenu2->setItemChecked(0,false);
	submenu2->setItemChecked(1,false);
	submenu2->setItemChecked(2,true);
	submenu2->setItemChecked(3,false);

	menu->addItem(L"Build",-1,true,true);
    submenu = menu->getSubMenu(2);
    submenu->addItem(L"Enable Progressive Build",GUI_ID_MENU_BUILD_PROGRESSIVE_BUILD,true,false,true,true);
    submenu->addItem(L"Build Final Geometry",GUI_ID_MENU_BUILD_BUILD_FINAL,true,false,false,false);
    submenu->setItemChecked(0,true);

	//gui::IGUIToolBar* bar = gui->addToolBar(main_panel,-1);
	VToolBar* bar = new VToolBar(gui,main_panel,-1,core::rect<s32>(0,0,10,10));

	video::ITexture* image = driver->getTexture("cube_icon_small.png");
	bar->addButton(GUI_ID_BUTTON_CUBE,0,L"Make a cube",image,0,false,false);

	image = driver->getTexture("cylinder_icon.png");
	bar->addButton(GUI_ID_BUTTON_CYLINDER,0,L"Make a cylinder",image,0,false,false);

	image = driver->getTexture("sphere_icon.png");
	bar->addButton(GUI_ID_BUTTON_SPHERE,0,L"Make a sphere",image,0,false,false);

	image = driver->getTexture("cone_icon.png");
	bar->addButton(GUI_ID_BUTTON_CONE,0,L"Make a cone",image,0,false,false);

	image = driver->getTexture("plane_icon.png");
	bar->addButton(GUI_ID_BUTTON_PLANE,0,L"Make a plane",image,0,false,false);

	image = driver->getTexture("add_icon_small.png");
	bar->addButton(GUI_ID_BUTTON_ADD,0,L"Add Geometry",image,0,false,false);

	image = driver->getTexture("subtract_icon_small.png");
	bar->addButton(GUI_ID_BUTTON_SUBTRACT,0,L"Subtract Geometry",image,0,false,false);

	image = driver->getTexture("semisolid_icon.png");
	bar->addButton(GUI_ID_BUTTON_SEMISOLID,0,L"Add Semisolid Geometry",image,0,false,false);

	image = driver->getTexture("intersect_icon.png");
	bar->addButton(GUI_ID_BUTTON_INTERSECT,0,L"Intersect Red Brush",image,0,false,false);

	image = driver->getTexture("clip_icon.png");
	bar->addButton(GUI_ID_BUTTON_CLIP,0,L"Clip Red Brush",image,0,false,false);

	image = driver->getTexture("rebuild_icon.png");
	bar->addButton(GUI_ID_BUTTON_REBUILD,0,L"Rebuild Geometry",image,0,false,false);

	image = driver->getTexture("save_icon.png");
	bar->addButton(GUI_ID_BUTTON_SAVE,0,L"Save",image,0,false,false);

	image = driver->getTexture("small_test_icon.png");
	bar->addButton(GUI_ID_BUTTON_TEXTURES,0,L"test",image,0,false,false);

	image = driver->getTexture("small_N_icon.png");
	bar->addButton(GUI_ID_BUTTON_NODES,0,L"test",image,0,false,false);

	MySkin* skin = new MySkin(EGST_WINDOWS_CLASSIC,driver);

	//gui::IGUISkin* skin = gui->getSkin();
	gui::IGUIFont* builtinfont = gui->getBuiltInFont();
	gui::IGUIFontBitmap* bitfont = 0;
	if (builtinfont && builtinfont->getType() == EGFT_BITMAP)
		bitfont = (IGUIFontBitmap*)builtinfont;

	IGUISpriteBank* bank = 0;
	skin->setFont(builtinfont);

	if (bitfont)
		bank = bitfont->getSpriteBank();

	skin->setSpriteBank(bank);


	gui::IGUIFont* font = gui->getFont("fonthaettenschweiler.bmp");
	if(font)
        skin->setFont(font);

    gui->setSkin(skin);
    skin->drop();

    skin->setColor(EGDC_BUTTON_TEXT,video::SColor(255,236,236,236));
    skin->setColor(EGDC_3D_FACE,video::SColor(255,16,16,16));
    skin->setColor(EGDC_EDITABLE,video::SColor(255,24,24,24));
    skin->setColor(EGDC_FOCUSED_EDITABLE,video::SColor(255,40,50,65));

    skin->setColor(EGDC_SCROLLBAR,video::SColor(255,0,0,0));

    skin->setColor(EGDC_WINDOW_SYMBOL,video::SColor(255,236,236,236)),
    skin->setColor(EGDC_3D_HIGH_LIGHT,video::SColor(255,32,32,32));
    skin->setColor(EGDC_3D_LIGHT,video::SColor(255,48,48,48));
    skin->setColor(EGDC_3D_SHADOW,video::SColor(255,32,32,32));
    skin->setColor(EGDC_3D_DARK_SHADOW,video::SColor(255,16,16,16));

    //skin->setColor(EGUI_)

    //disable transparent gui
    for(int i=0;i<irr::gui::EGDC_COUNT; i++)
    {
        video::SColor col = skin->getColor((EGUI_DEFAULT_COLOR)i);
        col.setAlpha(255);
        skin->setColor((EGUI_DEFAULT_COLOR)i,col);
    }

	//=================
	//

	// Make sure we don't try Cg without support for it
	if (UseCgShaders && !driver->queryFeature(video::EVDF_CG))
	{
		printf("Warning: No Cg support, disabling.\n");
		UseCgShaders=false;
	}

    UseHighLevelShaders = true;
    UseCgShaders = false;

	io::path vsFileName; // filename for the vertex shader
	io::path psFileName; // filename for the pixel shader




	// create materials

	video::IGPUProgrammingServices* gpu = driver->getGPUProgrammingServices();
	s32 newMaterialType1 = 0;
	s32 newMaterialType2 = 0;
	s32 newMaterialType3 = 0;

	if (gpu)
	{
		MyShaderCallBack2* mc = new MyShaderCallBack2();
		MyShaderCallBack* mc2 = new MyShaderCallBack();
		MyShaderCallBack* mc3 = new MyShaderCallBack();

		// create the shaders depending on if the user wanted high level
		// or low level shaders:

		if (UseHighLevelShaders)
		{
			// Choose the desired shader type. Default is the native
			// shader type for the driver, for Cg pass the special
			// enum value EGSL_CG
			const video::E_GPU_SHADING_LANGUAGE shadingLanguage = video::EGSL_DEFAULT;

			// create material from high level shaders (hlsl, glsl or cg)

			newMaterialType1 = gpu->addHighLevelShaderMaterialFromFiles(
				"vert_shader.txt", "vertexMain", video::EVST_VS_1_1,
				"frag_shader.txt", "pixelMain", video::EPST_PS_1_1,
				mc, video::EMT_SOLID, 0, shadingLanguage);

            newMaterialType2 = gpu->addHighLevelShaderMaterialFromFiles(
				"vert_shader2.txt", "vertexMain", video::EVST_VS_1_1,
				"frag_shader2.txt", "pixelMain", video::EPST_PS_1_1,
				mc2, video::EMT_SOLID, 0, shadingLanguage);

            newMaterialType3 = gpu->addHighLevelShaderMaterialFromFiles(
				"vert_shader3.txt", "vertexMain", video::EVST_VS_1_1,
				"frag_shader3.txt", "pixelMain", video::EPST_PS_1_1,
				mc3, video::EMT_TRANSPARENT_ADD_COLOR, 0, shadingLanguage);

		}

		mc->drop();
		mc2->drop();
		mc3->drop();
	}

	bool bMouseDown=false;
    bool rMouseDown=false;
    bool letterDown[26];
    bool numberDown[10];
    s32 clickx;
    s32 clicky;

	//============================================================================================

    LineHolder graph;
    LineHolder graph2;
    LineHolder graph3;
    LineHolder graph4,graph5;
    LineHolder nograph;
    polyfold my_poly;

    //0.785398
    //1.570796

    Reflected_SceneNode::SetBaseMaterialType(video::EMT_TRANSPARENT_ADD_COLOR);
    Reflected_SceneNode::SetSpecialMaterialType((video::E_MATERIAL_TYPE)newMaterialType2);

    geometry_scene scene(smgr,driver,&receiver,video::EMT_SOLID,(video::E_MATERIAL_TYPE)newMaterialType2);

    g_scene = &scene;

    core::matrix4 MAT;
    core::matrix4 MAT2;

    polyfold pf,pf1,pf2,pf3,pf4, cube, cube1, cube2, cylinder;

   // MAT.setRotationAxisRadians(1.570796,core::vector3df(1,0,0));

    scene.set_type(GEO_SOLID);

    //WriteGeometryToFile("poly.dat",&scene);

    //scene.ReadGeometryFromFile("poly.dat");

    //scene.WriteTextures("textures.txt");
    //scene.Write2("refl_serial.dat");

    scene.Read2("refl_serial.dat","textures.txt");

    scene.ReadSceneNodesFromFile("nodes.dat");



    cube = scene.elements[0].brush;
    cube.topology=TOP_CONVEX;

    //scene.set_type(GEO_EMPTY);
    int op_type = GEO_ADD;

    //==========
    Material_Groups_Base* material_groups_base = new Material_Groups_Base;
    material_groups_base->preinitialize(gui,&scene);

    Material_Group m0{"Standard",false,false,video::EMT_SOLID};
    Material_Group m1{"Curved",false,false,newMaterialType1};
    Material_Group m2{"Transparent",true,true,video::EMT_TRANSPARENT_ADD_COLOR};
    material_groups_base->material_groups.push_back(m0);
    material_groups_base->material_groups.push_back(m1);
    material_groups_base->material_groups.push_back(m2);

    scene.setMaterialGroupsBase(material_groups_base);
    //=========

    scene.rebuild_geometry();
    cube.make_convex();
    if(op_type == GEO_SUBTRACT)
        cube.make_concave();
    pf2 = scene.get_intersecting_geometry(cube);

    std::cout<<"Begin Testing:\n\n";

    polyfold no_poly;
    no_poly.topology = TOP_CONCAVE;
    clip_results results;
    results.n_intersections=0;

    //scene.elements[0].brush = pf2;
    for(int i=0;i<cube.faces.size();i++)
    {
       // cube.calc_center(i);
       // cube.calc_normal(i);
    }

    for(int i=0;i<pf2.faces.size();i++)
    {
       // pf2.calc_center(i);
       // pf2.calc_normal(i);
    }

   // pf3 = make_sphere(512,16,8,true);
    //scene.elements[0].brush = pf3;

    //

    //clip_poly77(cube,pf2,op_type,scene.base_type, results,graph4);
/*
    for(int p_i=0;p_i<pf3.faces[5].loops.size();p_i++)
    {
        std::cout<<p_i<<":\n";
        for(int i=0;i<pf3.faces[5].loops[p_i].vertices.size();i++)
            std::cout<<pf3.vertices[i].V.X<<","<<pf3.vertices[i].V.Y<<","<<pf3.vertices[i].V.Z<<"\n";
    }
    std::cout<<"\n";

    pf3.calc_loops4(5,nograph);
    pf3.sort_loops(5);
    */

//

    //add_pfold(pf2,pf1);
    //pf1.merge_faces();

    //add_pfold(pf3,pf1);
    //add_pfold(pf2,pf1);
   // add_pfold(pf4,pf1);

   // pf1.merge_faces();
   // pf1.simplify_edges();
   //std::cout<<results.n_intersections<<" intersections\n";
   //std::cout<<"ok\n";

   //pf1.calc_loops4(5,nograph);
    //add_pfold(pf3,pf2);
    //pf3.make_convex2();
/*
    for(int i=0;i<pf3.faces.size();i++)
    {
        //std::cout<<i<<":\n";
        pf3.calc_normal(i);

        for(int p=0;p<pf3.faces[i].loops.size();p++)
        {
            pf3.calc_loop_bbox(i,p);
            pf3.set_loop_solid(i,p);
        }
    }

    pf3.make_convex2(graph4);
    pf3.make_concave();
    */
   // pf3.topology=TOP_CONCAVE;
   // pf3.recalc_faces();

    pf=pf2;
    //pf=scene.elements[4].geometry;

    //buffer->Material.setTexture(0, driver->getTexture("wall.bmp"));
    //scene.getMeshNode()->getMesh()->getMeshBuffer(5)->getMaterial().setTexture(0, driver->getTexture("terrain2.jpg"));
   // std::cout<<scene.getMeshNode()->getMesh()->getMeshBufferCount()<<" meshes\n";
   //scene.getMeshNode()->SetFaceTexture(0,driver->getTexture("terrain2.jpg"));
   //scene.getMeshNode()->SetFaceMaterialType(0,(video::E_MATERIAL_TYPE)newMaterialType2);

/*
    for(int f_i=0; f_i<pf.faces.size(); f_i++)
    {
        std::cout<<f_i<<":\n";
            for(int p_i=0; p_i<pf.faces[f_i].loops.size();p_i++)
        {
                 std::cout<<"bounds: "<<pf.faces[f_i].loops[p_i].min_x<<","<<pf.faces[f_i].loops[p_i].max_x<<
                                        "  "<<pf.faces[f_i].loops[p_i].min_z<<","<<pf.faces[f_i].loops[p_i].max_z<<"\n";
        }
    }
*/
    //pf.merge_faces2();

    scene::CMeshSceneNode* mesh_node = NULL;
/*
    for(int p=0;p<pf.faces[5].loops.size();p++)
        {
        if(pf.faces[5].loops[p].vertices.size()==3 && pf.is_closed_loop(5,p)==false)
            {
            std::cout<<"triangle\n";
            int v0 = pf.faces[5].loops[p].vertices[0];
            int v1 = pf.faces[5].loops[p].vertices[1];
            int e_i = pf.find_edge(v0,v1);
            int v_0 = pf.get_point_or_add(pf.vertices[v0].V + (pf.vertices[v1].V - pf.vertices[v0].V)*0.5);
            pf.bisect_edge(e_i,v_0,0,0);
            }
        }
*/

    //===========
/*
    scene::SMeshBuffer* buffer;
    scene::SMesh* mesh = new scene::SMesh;

    buffer = new scene::SMeshBuffer();
	buffer->Material.Lighting = false;
	buffer->Material.setTexture(0, driver->getTexture("wall.bmp"));
    for(int f_i =0 ;f_i<pf.faces.size(); f_i++)
    {
        //if(f_i==3)
        {
        buffer = new scene::SMeshBuffer();
        buffer->Material.Lighting = false;
        buffer->Material.setTexture(0, driver->getTexture("wall.bmp"));

        pf.trianglize(f_i,buffer,graph4,graph4);

        mesh->addMeshBuffer(buffer);
        //std::cout<<buffer->getIndexCount()<<"\n";
        //for(int i=0;i<buffer->getIndexCount();i+=3)
        //    std::cout<<buffer->Indices[i]<<" "<<buffer->Indices[i+1]<<" "<<buffer->Indices[i+2]<<"\n";
        }
    }
    mesh_node = new scene::CMeshSceneNode(mesh,smgr->getRootSceneNode(),smgr,747);
    mesh_node->SetBox(pf.bbox);
    mesh->drop();
*/
    //=============

    //scene.ExportFinalMesh("final_mesh.msh");

    addDrawLines(pf, graph,graph2,graph3);

    //=============================================================================================
   /* video::SMaterial someMaterial;
    someMaterial.Lighting = false;
    someMaterial.Thickness = 1.0;
    someMaterial.MaterialType = video::EMT_SOLID;

    video::SMaterial someMaterial_15;
    someMaterial_15.Lighting = false;
    someMaterial_15.Thickness = 1.5;
    someMaterial_15.MaterialType = video::EMT_SOLID;

    video::SMaterial someMaterial_2;
    someMaterial_2.Lighting = false;
    someMaterial_2.Thickness = 2.0;
    someMaterial_2.MaterialType = video::EMT_SOLID;*/

	device->getCursorControl()->setVisible(true);

	int lastFPS = -1;

	core::rect<s32> quad_rect(core::position2d<s32>(32,20),main_panel->getAbsolutePosition().LowerRightCorner);

    CameraQuad* cameraQuad = new CameraQuad(gui, main_panel,
		//GUI_ID_CAMERA_QUAD, core::rect<s32>(core::position2d<s32>(36,24), core::dimension2d<u32>(900,600)), driver);
		GUI_ID_CAMERA_QUAD, quad_rect, driver);

    core::rect<s32> tool_panel_r(core::position2d<s32>(900,0), core::vector2di(1200, 680));

    multi_tool_panel* tool_panel = new multi_tool_panel(gui,gui->getRootGUIElement(),-1,
            tool_panel_r);

    CMeshSceneNode::initialize_unique_color(driver);


    cameraQuad->initialize(smgr,&scene);
    cameraQuad->setGridSnap(8);
    cameraQuad->setRotateSnap(7.5);

    //((TestPanel_3D*)cameraQuad->getPanel(0))->overrideMeshNode(mesh_node);
    //((TestPanel_3D*)cameraQuad->getPanel(0))->setTotalGeometry(&pf);
    ((TestPanel_3D*)cameraQuad->getPanel(0))->SetViewStyle(PANEL3D_VIEW_RENDER);
    //((TestPanel_3D*)cameraQuad->getPanel(0))->AddGraph(graph4);

    material_groups_base->initialize(L"Materials", GUI_ID_MATERIAL_GROUPS_BASE, tool_panel);
    Material_Groups_Tool::initialize(gui,&scene,material_groups_base, tool_panel);

    TexturePicker_Base* texture_picker_base = new TexturePicker_Base;
    texture_picker_base->initialize(L"Textures", GUI_ID_TEXTURES_BASE, gui,&scene, tool_panel);
    TexturePicker_Tool::initialize(texture_picker_base, tool_panel);
    scene.setTexturePickerBase(texture_picker_base);

    GeometryFactory::initialize(gui,&scene);
    Texture_Adjust_Tool::initialize(gui,&scene);

    NodeProperties_Base* node_properties_base = new NodeProperties_Base;
    node_properties_base->initialize(L"Properties", GUI_ID_NODE_PROPERTIES_BASE, gui,&scene, tool_panel);
    NodeProperties_Tool::initialize(node_properties_base, tool_panel);

    ListReflectedNodes_Base* reflected_nodes_base = new ListReflectedNodes_Base;

    reflected_nodes_base->initialize(L"Classes",GUI_ID_NODE_CLASSES_BASE,gui,&scene, tool_panel);
    ListReflectedNodes_Tool::initialize(reflected_nodes_base, tool_panel);
    scene.set_choose_reflected_node_base(reflected_nodes_base);

    //tool_panel->add_tool(reflected_nodes_base);

    //multi_tool::initialize(tool_panel);

    texture_picker_base->addTexture("terrain2.jpg");
    texture_picker_base->addTexture("wall.bmp");
    texture_picker_base->addTexture("water3.jpg");
    texture_picker_base->addTexture("../media/textures/greek_cornice.jpg","AI");
    texture_picker_base->addTexture("../media/textures/temple_wall.jpg","AI");
    texture_picker_base->addTexture("../media/textures/temple_floor.jpg","AI");
    texture_picker_base->addTexture("../media/textures/carved_stone_buddha.jpg","AI");
    texture_picker_base->addTexture("../media/textures/ganesha_stone0.jpg","AI");
    texture_picker_base->addTexture("../media/textures/ganesha_stone1.jpg","AI");
    texture_picker_base->addTexture("../media/textures/greek_cornice.jpg","AI");
    texture_picker_base->addTexture("../media/textures/kama_sutra.jpg","AI");

    for(int i=0;i<10;i++)
    {
    texture_picker_base->addTexture("terrain2.jpg");
    texture_picker_base->addTexture("wall.bmp");
    texture_picker_base->addTexture("water3.jpg");
    }
    //make an alpha texture
    //video::IImage* img = makeAlphaImage(driver,driver->getTexture("water.jpg"),160);
    //video::ITexture* water_alpha_tex = driver->addTexture(irr::io::path("water_alpha"),img);
    //texture_picker_base->addTexture(water_alpha_tex,"water_alpha","alpha");
    //img->drop();

    MakeCircleImages(driver);

    bool s_down=false;

	while(device->run())
		if (device->isWindowActive())
	{
		driver->beginScene(true, true, video::SColor(255,32,32,32));

		u32 cnt = driver->getDynamicLightCount();
		//std::cout<<cnt<<"\n";

		cameraQuad->render();
        gui->drawAll();

		driver->endScene();

		int fps = driver->getFPS();

		if (lastFPS != fps)
		{
			core::stringw str = L"Das Irrlicht Engine  [";
			str += driver->getName();
			str += "] FPS:";
			str += fps;

			device->setWindowCaption(str.c_str());
			lastFPS = fps;
		}
	}

	device->drop();

	return 0;
}
