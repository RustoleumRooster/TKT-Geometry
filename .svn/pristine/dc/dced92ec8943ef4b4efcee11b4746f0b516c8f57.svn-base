#ifndef _BUFFER_MANAGER_H_
#define _BUFFER_MANAGER_H_

#include <irrlicht.h>
#include <vector>
#include <array>

#include "CMeshSceneNode.h"
#include "texture_picker.h"
#include "edit_env.h"


using namespace irr;
using namespace scene;

class polyfold;

struct MeshBuffer_Chunk
{
    IMeshBuffer* buffer;
    unsigned int begin_i;
    unsigned int end_i;
};

struct TextureMaterial
{
    video::ITexture* texture;
    int materialGroup;
};

class MeshNode_Interface
{
public:
    MeshNode_Interface(scene::ISceneManager* smgr_,video::IVideoDriver* driver_,MyEventReceiver* receiver,video::E_MATERIAL_TYPE base_material_type_, video::E_MATERIAL_TYPE special_material_type_);
    MeshNode_Interface();
    ~MeshNode_Interface();

    void init(scene::ISceneManager* smgr_,video::IVideoDriver* driver_,MyEventReceiver* receiver,video::E_MATERIAL_TYPE base_material_type_, video::E_MATERIAL_TYPE special_material_type_);


    void generate_mesh_node(geometry_scene* geo_scene);
    virtual MeshBuffer_Chunk get_mesh_buffer_by_face(int f_i)=0;

    //virtual IMeshBuffer* get_mesh_buffer_by_original_face(int b_i, int f_i)=0;

    //CMeshSceneNode* getMeshNode() {return mesh_node;}

    void recalc_uvs_for_face_cube(polyfold*, poly_face*, int f_i);
    void recalc_uvs_for_face_cylinder(polyfold*, poly_face*, int f_i);
    void recalc_uvs_for_face_sphere(polyfold*, poly_face*, int f_i);
    void recalc_uvs_for_face_dome(polyfold*, poly_face*, int f_i);

    CMeshSceneNode* addMeshSceneNode(scene::ISceneManager* smgr,geometry_scene* geo_scene);

protected:

    virtual void generate_mesh_buffer(geometry_scene* geo_scene,SMesh*)=0;
    void generate_uvs(geometry_scene* geo_scene);


    scene::SMesh* m_mesh = NULL;
    //CMeshSceneNode* mesh_node=NULL;
    std::vector<TextureMaterial> materials_used;
    std::vector<int> mg_to_reference_face;

    //std::vector<int> face_to_mb_begin;
    //std::vector<int> face_to_mb_end;

    scene::ISceneManager* smgr=NULL;
    video::IVideoDriver* driver=NULL;
    TexturePicker* texture_picker=NULL;
    MyEventReceiver* event_receiver=NULL;

    video::E_MATERIAL_TYPE base_material_type;
    video::E_MATERIAL_TYPE special_material_type;
    friend class geometry_scene;
};

class MeshNode_Interface_Edit : public MeshNode_Interface
{
public:
    virtual MeshBuffer_Chunk get_mesh_buffer_by_face(int f_i);
    int get_buffer_index_by_face(int i);
protected:
    //virtual IMeshBuffer* get_mesh_buffer_by_original_face(int b_i, int f_i);
    virtual void generate_mesh_buffer(geometry_scene* geo_scene,SMesh*);
    //virtual void generate_uvs(geometry_scene* geo_scene);
    std::vector<int> face_to_mb_buffer;

    friend class geometry_scene;
};

class MeshNode_Interface_Final : public MeshNode_Interface
{


public:
   virtual  MeshBuffer_Chunk get_mesh_buffer_by_face(int f_i);
   int get_material_reference_face(int material_group){return mg_to_reference_face[material_group];}

protected:
    //virtual IMeshBuffer* get_mesh_buffer_by_original_face(int b_i, int f_i);
    virtual void generate_mesh_buffer(geometry_scene* geo_scene,SMesh*);
    //virtual void generate_uvs(geometry_scene* geo_scene);

    std::vector<int> face_to_mb_buffer;
    std::vector<int> face_to_mb_begin;
    std::vector<int> face_to_mb_end;

    friend class geometry_scene;
};



#endif
