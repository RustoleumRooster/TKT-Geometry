
#include <irrlicht.h>
#include <iostream>
#include "GUI_tools.h"


using namespace irr;

//multi_tool_panel* multi_tool::panel = NULL;

multi_tool_panel::multi_tool_panel(gui::IGUIEnvironment* env, gui::IGUIElement* parent,s32 id,core::rect<s32> rect) :
    gui::IGUIElement(gui::EGUIET_WINDOW,env,parent,id,rect)
{

    clientRect = NULL;//new gui::IGUIElement(gui::EGUIET_ELEMENT,env,this,-1,core::rect<s32>(core::vector2di(0,64),core::vector2di(200,400)));

}

gui::IGUIElement* multi_tool_panel::getClientRect()
{
    return clientRect;
}

void multi_tool_panel::add_tool(tool_base* tool)
{

    for(int i=0;i<my_tools.size();i++)
    {
        if(tool->getID() == my_tools[i]->getID())
        {
            show_tool(i);
            return;
        }
    }

    my_tools.push_back(tool);

    do_layout();

}

void multi_tool_panel::remove_tool(int tool_no)
{
    std::vector<tool_base*> new_tools;

    for(int i=0;i<my_tools.size();i++)
        if(i != tool_no)
            new_tools.push_back(my_tools[i]);

    my_tools = new_tools;

    do_layout();
}

void multi_tool_panel::nameChange(tool_base* tool)
{
    for(int i=0;i<my_tools.size();i++)
    {
        if(my_tools[i] == tool)
        {
            if(i<my_headers.size())
                my_headers[i]->setText(tool->getName());
        }
    }
}

void multi_tool_panel::do_layout()
{
    core::list<gui::IGUIElement*> child_list = this->getChildren();

    core::list<gui::IGUIElement*>::Iterator it = child_list.begin();
    for(;it != child_list.end();++it)
    {
        int id = (*it)->getID();
        //if( id != GUI_ID_TEXTURE_SCROLL_BAR )
            this->removeChild(*it);
    }

    my_headers.clear();

    for(int i=0;i<my_tools.size(); i++)
    {
        core::rect<s32> header_rect(core::vector2di(0,24*i),core::vector2di(getRelativePosition().getWidth(),24*(i+1)));
        tool_header* header = new tool_header(Environment,this,ID+1+i,header_rect);
        header->tool_no=i;
        header->setText(my_tools[i]->getName());
        my_headers.push_back(header);
    }

    updateClientRect();

    if(my_tools.size() > 0)
    {
        my_tools[my_tools.size()-1]->show();
        my_headers[my_tools.size()-1]->can_select = false;
    }
}

void multi_tool_panel::draw()
{
    if (!IsVisible)
		return;

	gui::IGUISkin* skin = Environment->getSkin();
	video::IVideoDriver* driver = Environment->getVideoDriver();

    //skin->draw2DRectangle(this, video::SColor(255,80,80,80),
    //                     AbsoluteRect,
    //                     &AbsoluteClippingRect);
    skin->draw3DToolBar(this,
                         AbsoluteRect,
                         &AbsoluteClippingRect);
    IGUIElement::draw();
}

void multi_tool_panel::show_tool(int tool_no)
{
    if(tool_no != my_tools.size()-1)
    {
        std::vector<tool_base*> new_list;

        for(int i=0;i<my_tools.size();i++)
            if(i != tool_no)
                new_list.push_back(my_tools[i]);

        new_list.push_back(my_tools[tool_no]);
        my_tools = new_list;

        do_layout();
    }
}

bool multi_tool_panel::OnEvent(const SEvent& event)
{
    if (isEnabled())
	{
	    if(event.EventType == EET_GUI_EVENT)
        {
            if(event.GUIEvent.EventType == gui::EGET_BUTTON_CLICKED)
            {
                for(tool_header* header: my_headers)
                {
                    if(event.GUIEvent.Caller == header->CloseButton)
                    {
                     //std::cout<<"close! "\n";
                     remove_tool(header->tool_no);
                     return true;
                    }
                }

                tool_header* th = (tool_header*)event.GUIEvent.Caller;
                show_tool(th->tool_no);

                return true;
            }
        }
        else if(event.EventType ==  EET_MOUSE_INPUT_EVENT)
        {
            switch(event.MouseInput.Event)
            {
                case EMIE_RMOUSE_PRESSED_DOWN:
                    {
                        //if (Environment->hasFocus(this))
                        if(!AbsoluteClippingRect.isPointInside( core::position2d<s32>(event.MouseInput.X, event.MouseInput.Y ) ))
                        {
                            Environment->removeFocus(this);
                            return true;
                        }
                    }
            }
        }
	}

	return false;
}

void multi_tool_panel::updateClientRect()
{
    int nHeaders = my_tools.size();

    if(clientRect)
    {
        //clientRect->drop();
        clientRect->remove();
    }

    core::vector2di v1 = AbsoluteRect.LowerRightCorner - AbsoluteRect.UpperLeftCorner;
    v1-=core::vector2di(1,1);
    //v1.X+=16;

    clientRect = new gui::IGUIElement(gui::EGUIET_ELEMENT,Environment,this,-1,
                        core::rect<s32>(core::vector2di(1,nHeaders*24),v1));
}

void tool_base::setName(std::wstring txt)
{
    name=txt;
    panel->nameChange(this);
}

void tool_base::initialize(std::wstring name_, int my_id, gui::IGUIEnvironment* env_, geometry_scene* g_scene_,multi_tool_panel* panel_ )
{
    name = name_;
    env=env_;
    g_scene= g_scene_;
    panel = panel_;
    my_ID = my_id;
}

void tool_header::setText(std::wstring txt)
{
    if(my_text)
        my_text->remove();
    my_text = Environment->addStaticText(txt.c_str(),core::rect<s32>(core::vector2di(0+4,0 + 2),core::vector2di(200,24)),false,false,this,-1);
    //my_text->setOverrideColor(video::SColor(255,255,255,255));
}

tool_header::tool_header(gui::IGUIEnvironment* env, gui::IGUIElement* parent,s32 id,core::rect<s32> rect)
    :gui::IGUIElement(gui::EGUIET_ELEMENT,env,parent,id,rect)
{
    gui::IGUISkin* skin = Environment->getSkin();
    int buttonw = buttonw = skin->getSize(gui::EGDS_WINDOW_BUTTON_WIDTH);
    s32 posx = RelativeRect.getWidth() - buttonw - 4;

    CloseButton = Environment->addButton(core::rect<s32>(posx, 3, posx + buttonw, 3 + buttonw), this, -1,
		L"", skin ? skin->getDefaultText(gui::EGDT_WINDOW_CLOSE) : L"Close" );
	CloseButton->setSubElement(true);

	gui::IGUISpriteBank* sprites = skin->getSpriteBank();
	if ( sprites )
    {
        CloseButton->setSpriteBank(sprites);
		CloseButton->setSprite(gui::EGBS_BUTTON_UP, skin->getIcon(gui::EGDI_WINDOW_CLOSE), skin->getColor(gui::EGDC_WINDOW_SYMBOL));
		CloseButton->setSprite(gui::EGBS_BUTTON_DOWN, skin->getIcon(gui::EGDI_WINDOW_CLOSE), skin->getColor(gui::EGDC_WINDOW_SYMBOL));
    }
}

bool tool_header::OnEvent(const SEvent& event)
{
    if (isEnabled())
	{
		if(event.EventType == EET_MOUSE_INPUT_EVENT)
        {
            if(event.MouseInput.Event == EMIE_LMOUSE_LEFT_UP)
            {
                SEvent e;
                e.EventType = EET_GUI_EVENT;
                e.GUIEvent.EventType = gui::EGET_BUTTON_CLICKED;
                e.GUIEvent.Caller = this;
                Parent->OnEvent(e);
                return true;
            }
		}
        else if(event.EventType == EET_GUI_EVENT)
        {
            if(can_select)
            {
                gui::IGUISkin* skin = Environment->getSkin();
                if(event.GUIEvent.EventType == gui::EGET_ELEMENT_HOVERED)
                {
                    hovered = true;
                    if(my_text)
                        my_text->setOverrideColor(skin->getColor(gui::EGDC_HIGH_LIGHT_TEXT));
                }
                else if(event.GUIEvent.EventType == gui::EGET_ELEMENT_LEFT)
                {
                    hovered = false;
                    if(my_text)
                        my_text->setOverrideColor(skin->getColor(gui::EGDC_BUTTON_TEXT));
                }
            }
        }
	}

	gui::IGUIElement::OnEvent(event);
}

void tool_header::draw()
{
    if(hovered)
    {
    gui::IGUISkin* skin = Environment->getSkin();
    skin->draw2DRectangle(this,skin->getColor(gui::EGDC_3D_LIGHT),getAbsolutePosition());
    }
    gui::IGUIElement::draw();
}

