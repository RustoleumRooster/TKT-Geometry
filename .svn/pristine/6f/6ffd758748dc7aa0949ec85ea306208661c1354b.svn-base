

#include <irrlicht.h>
#include "material_groups.h"
#include "edit_env.h"
#include "edit_classes.h"
#include "geometry_scene.h"

using namespace irr;

extern IrrlichtDevice* device;

Material_Groups_Base* Material_Groups_Tool::base = NULL;
gui::IGUIEnvironment* Material_Groups_Tool::env = NULL;
geometry_scene* Material_Groups_Tool::g_scene = NULL;
multi_tool_panel* Material_Groups_Tool::panel = NULL;

Material_Groups_Widget::mGroups_struct Material_Groups_Widget::mg_struct{0};
Material_Groups_Widget::nSelected_struct Material_Groups_Widget::sel_struct{2};


REFLECT_STRUCT_BEGIN(Material_Groups_Widget::nSelected_struct)
    REFLECT_STRUCT_MEMBER(nSelected)
REFLECT_STRUCT_END()

REFLECT_STRUCT_BEGIN(Material_Groups_Widget::mGroups_struct)
    REFLECT_STRUCT_MEMBER(group_no)
REFLECT_STRUCT_END()

Material_Groups_Widget::Material_Groups_Widget(gui::IGUIEnvironment* env, gui::IGUIElement* parent,geometry_scene* g_scene_,s32 id,core::rect<s32> rect)
    : gui::IGUIElement(gui::EGUIET_ELEMENT,env,parent,id,rect), g_scene(g_scene_)
{
    MyEventReceiver* receiver = (MyEventReceiver*)device->getEventReceiver();
    receiver->Register(this);
}

Material_Groups_Widget::~Material_Groups_Widget()
{
    MyEventReceiver* receiver = (MyEventReceiver*)device->getEventReceiver();
    receiver->UnRegister(this);
}

void Material_Groups_Widget::show()
{
    core::vector2di form_pos(8,60);
    core::vector2di form_pos2(8,28);

    form = new Reflected_GUI_Edit_Form(Environment,this,NULL,GUI_ID_REFLECTED_BASE,
                                            core::rect<s32>(form_pos,core::dimension2du(128,128)));
    form2 = new Reflected_GUI_Edit_Form(Environment,this,NULL,GUI_ID_REFLECTED_BASE+1,
                                            core::rect<s32>(form_pos2,core::dimension2du(128,128)));

    reflect::TypeDescriptor_Struct* typeDesc = (reflect::TypeDescriptor_Struct*)reflect::TypeResolver<mGroups_struct>::get();
   // reflect::TypeDescriptor* typeDesc2 = reflect::TypeResolver<nSelected_struct>::get();
    //typeDesc->addFormWidgets("", form,true);
    typeDesc->addFormWidget(form,NULL,std::vector<int>{},0,true,true,0);

    int next_ID = form->ShowWidgets(GUI_ID_REFLECTED_BASE+2);

    Int_StaticField* f = new Int_StaticField();

    f->setText("selected faces");

    //*obj2 = g_scene->getSelectedFaces().size();

    //f->obj = (int*)&sel_struct;
    f->offset=0;

    form2->addEditField(f);

    next_ID = form2->ShowWidgets(next_ID);

    sel_struct.nSelected = g_scene->getSelectedFaces().size();

    int ypos = form->getTotalHeight()+64;

    OK_BUTTON_ID=next_ID;

    Environment->addButton(core::rect<s32>(form_pos+core::vector2di(120,ypos),form_pos+core::vector2di(180,ypos+28)),this,OK_BUTTON_ID,L"Apply");

    bringToFront(form);

    SEvent event;
    event.EventType = EET_USER_EVENT;
    event.UserEvent.UserData1=USER_EVENT_SELECTION_CHANGED;
    this->OnEvent(event);

}

void Material_Groups_Widget::refresh()
{
    if(form)
    {
        form->remove();
    }

    core::vector2di form_pos(8,60);
    form = new Reflected_GUI_Edit_Form(Environment,this,NULL,GUI_ID_REFLECTED_BASE,
                                            core::rect<s32>(form_pos,core::dimension2du(96,128)));

    bool editable = this->sel_struct.nSelected > 0;

    reflect::TypeDescriptor_Struct* typeDesc = (reflect::TypeDescriptor_Struct*)reflect::TypeResolver<mGroups_struct>::get();
//    typeDesc->addFormWidgets("", form,editable);
    typeDesc->addFormWidget(form,NULL,std::vector<int>{},0,true,editable,0);

    int next_ID = form->ShowWidgets(GUI_ID_REFLECTED_BASE+2);

    //form->read(&mg_struct);
    form2->read(&sel_struct);

    FormField* f = form->edit_fields;

    if( g_scene->getSelectedFaces().size() > 1)
    {
        int f_0 = g_scene->getSelectedFaces()[0];
        int brush_0 = g_scene->get_total_geometry()->faces[f_0].original_brush;
        int face_0 = g_scene->get_total_geometry()->faces[f_0].original_face;

        for( int f_i : g_scene->getSelectedFaces())
        {
            int b_i = g_scene->getSelectedFaces()[0];

            int brush_j = g_scene->get_total_geometry()->faces[f_i].original_brush;
            int face_j = g_scene->get_total_geometry()->faces[f_i].original_face;

            bool b = (g_scene->elements[brush_j].brush.faces[face_j].material_group ==
                        g_scene->elements[brush_0].brush.faces[face_0].material_group);

            if(b)
            {
                mg_struct.group_no.value = g_scene->elements[brush_0].brush.faces[face_0].material_group;
                form->read(&mg_struct);
                bWrite=true;
            }
            else
            {
                f->setActive(false);
                bWrite=false;
            }
        }
    }
    else if( g_scene->getSelectedFaces().size() == 1)
    {
        int f_0 = g_scene->getSelectedFaces()[0];
        int brush_0 = g_scene->get_total_geometry()->faces[f_0].original_brush;
        int face_0 = g_scene->get_total_geometry()->faces[f_0].original_face;

        mg_struct.group_no.value = g_scene->elements[brush_0].brush.faces[face_0].material_group;
        form->read(&mg_struct);
        bWrite=true;
    }
}


void Material_Groups_Widget::click_OK()
{
    if(!bWrite)
        return;

    std::vector<int> selection = this->g_scene->getSelectedFaces();

    this->form->write(&mg_struct);

    for(int b_i: selection)
    {
        int brush_j = g_scene->get_total_geometry()->faces[b_i].original_brush;
        int face_j = g_scene->get_total_geometry()->faces[b_i].original_face;

        poly_face* f = &g_scene->elements[brush_j].brush.faces[face_j];

        f->material_group = mg_struct.group_no.value;
        this->g_scene->get_total_geometry()->faces[b_i].material_group == mg_struct.group_no.value;
    }
}


bool Material_Groups_Widget::OnEvent(const SEvent& event)
{

    if(event.EventType == irr::EET_USER_EVENT)
    {
        switch(event.UserEvent.UserData1)
        {
            case USER_EVENT_SELECTION_CHANGED:
            {
                this->sel_struct.nSelected = g_scene->getSelectedFaces().size();

                if(g_scene->getSelectedFaces().size() > 0)
                {
                    int b_i = g_scene->getSelectedFaces()[0];

                    int brush_j = g_scene->get_total_geometry()->faces[b_i].original_brush;
                    int face_j = g_scene->get_total_geometry()->faces[b_i].original_face;

                    poly_face* f = &g_scene->elements[brush_j].brush.faces[face_j];

                    if((g_scene->elements[brush_j].brush.surface_groups[ f->surface_group ].type == SURFACE_GROUP_CYLINDER ||
                        g_scene->elements[brush_j].brush.surface_groups[ f->surface_group ].type == SURFACE_GROUP_SPHERE ||
                        g_scene->elements[brush_j].brush.surface_groups[ f->surface_group ].type == SURFACE_GROUP_DOME
                        )
                       && !dont_sg_select)
                    {
                        dont_sg_select=true; //avoid an infinite loop
                        g_scene->selectSurfaceGroup();
                    }
                    dont_sg_select=false;
                }

                refresh();
            } break;
        }
        return true;
    }
    else if(event.EventType == EET_GUI_EVENT)
    {
        s32 id = event.GUIEvent.Caller->getID();
        gui::IGUIEnvironment* env = device->getGUIEnvironment();

        switch(event.GUIEvent.EventType)
        {
            case EGET_BUTTON_CLICKED:
            {
                if(id==OK_BUTTON_ID)
                {
                    click_OK();
                    return true;
                }
                break;
            }
            case EGET_COMBO_BOX_CHANGED:
            {
                bWrite = true;
                return true;
                break;
            }
        }
    }

    return gui::IGUIElement::OnEvent(event);
}

void Material_Groups_Base::show()
{
    core::rect<s32> client_rect(core::vector2di(0,0),
                                core::dimension2du(this->panel->getClientRect()->getAbsolutePosition().getWidth(),
                                                   this->panel->getClientRect()->getAbsolutePosition().getHeight()));

    Material_Groups_Widget* widget = new Material_Groups_Widget(env,this->panel->getClientRect(),g_scene,GUI_ID_MATERIAL_GROUPS_BASE,client_rect);

    widget->show();
    widget->drop();
}

void Material_Groups_Base::apply_material_to_buffer(scene::SMeshBuffer* buffer, int material_no)
{
    //std::cout<<material_no<<"\n";
    switch(material_no)
    {
    case 0:
        {
            buffer->Material.MaterialType = video::EMT_SOLID;

        } break;
    case 1:
        {
            //buffer->Material.MaterialType = video::EMT_SOLID;
            buffer->Material.MaterialType = (video::E_MATERIAL_TYPE)material_groups[1].material_no;
            //buffer->Material.MaterialType = video::EMT_TRANSPARENT_ADD_COLOR;
            //buffer->Material.MaterialType = video::EMT
        } break;
    case 2:
        {
            buffer->Material.MaterialType = video::EMT_TRANSPARENT_ADD_COLOR;
            //buffer->Material.MaterialType = video::EMT_TRANSPARENT_ALPHA_CHANNEL;
            buffer->Material.BackfaceCulling = false;
        } break;
    };
}

