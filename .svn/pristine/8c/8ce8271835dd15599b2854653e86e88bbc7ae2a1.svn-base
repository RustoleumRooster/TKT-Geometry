#include <irrlicht.h>
#include <iostream>
#include "csg_classes.h"
#include "tolerances.h"

using namespace irr;



bool is_left_from(core::vector3df v0, core::vector3df v1, core::vector3df straight, core::vector3df N)
{
    core::vector3df cp0 = v0.crossProduct(straight);
    core::vector3df cp1 = v1.crossProduct(straight);

    if(cp0.dotProduct(N) > 0.0001 && cp1.dotProduct(N) < -0.0001)
        return true;

    core::vector3df cp = v0.crossProduct(v1);
    if(cp.dotProduct(N) > 0.0001)
        return true;
    return false;
}


bool is_left_from2(core::vector3df v0, core::vector3df v1, core::vector3df straight, core::vector3df N)
{
    core::vector3df cp0 = v0.crossProduct(straight);
    core::vector3df cp1 = v1.crossProduct(straight);

    if(cp0.dotProduct(N) < -0.001 && cp1.dotProduct(N) > 0.001)
        return false;
    else if(cp0.dotProduct(N) > 0.001 && cp1.dotProduct(N) < -0.001)
        return true;

    core::vector3df cp = v0.crossProduct(v1);
    if(cp.dotProduct(N) > 0.001)
        return true;
    //std::cout<<"bla "<<cp.X<<", "<<cp.Y<<", "<<cp.Z<<" "<<cp.dotProduct(N)<<"\n";
    return false;
}

int polyfold::get_opposite_end(int e_i, int v_i)
{
    if(this->edges[e_i].v0 == v_i)
        return this->edges[e_i].v1;
    else return this->edges[e_i].v0;
}

int polyfold::get_opposite_end(poly_edge edge, int v_i)
{
    if(edge.v0 == v_i)
        return edge.v1;
    else return edge.v0;
}

int polyfold::get_next_loop_edge_going_left(int f_i, int e_i, int v_i)
{
    int ret;
    std::vector<int> links_ = get_edges_from_point(f_i,e_i,v_i);

    std::vector<int> links;
    for(int i: links_)
        if(this->edges[i].p2 != -1)
            links.push_back(i);

    if(links.size()==1)
    {
        ret = links[0];
    }
    else if(links.size()>1)
    {
        std::vector<core::vector3df> vecs;
        for(int e_j : links)
        {
            int v_j = this->get_opposite_end(e_j,v_i);
            vecs.push_back(this->vertices[v_j].V - this->vertices[v_i].V);
        }
        core::vector3df straight_ahead = this->vertices[v_i].V - this->vertices[this->get_opposite_end(e_i,v_i)].V;

        for(int i=0; i<links.size()-1; i++)
            for(int j=i+1; j<links.size(); j++)
            {
                if(is_left_from2(vecs[j],vecs[i],straight_ahead, this->faces[f_i].getOrientingNormal()))
                {
                    core::vector3df tv = vecs[i];
                    vecs[i]=vecs[j];
                    vecs[j]= tv;

                    int ti = links[i];
                    links[i]=links[j];
                    links[j]=ti;
                }
            }

        ret = links[0];
    }
    else
        ret = -1;

    return ret;
}

std::vector<int> polyfold::get_loop_going_left(int f_i, int v_0, int e_0, int v_1,LineHolder& graph)
{
    std::vector<int> e_loop;
    e_loop.push_back(e_0);
    //graph.lines.push_back(core::line3df(this->getVertex(e_0,0).V,this->getVertex(e_0,1).V));
    int v_i = v_1;
    int e_i = e_0;

    while(true)
        {
            e_i = get_next_loop_edge_going_left(f_i,e_i,v_i);

            if(e_i == -1)
            {
                std::cout<<"*Error calc loops search space zero\n";
                return e_loop;
            }

            if(e_i == e_0)
                return e_loop;

            v_i = this->get_opposite_end(e_i,v_i);

            e_loop.push_back(e_i);
        };
}

core::vector3df poly_face::getOrientingNormal()
{
    if(is_parallel_normal(this->m_normal,core::vector3df(0,1,0)))
        return core::vector3df(0,1,0);
    else if(bFlippedNormal)
        return this->m_normal*-1;
    else
        return this->m_normal;
}

bool polyfold::is_clockwise_loop(int f_i,int p_i)
{
    f32 testz = (this->faces[f_i].loops[p_i].max_z - this->faces[f_i].loops[p_i].min_z)*0.5 + this->faces[f_i].loops[p_i].min_z;
    f32 testx = this->faces[f_i].loops[p_i].min_x - 10;
    int res = this->left_right_test(f_i,p_i,testx,testz);
    if(res==0)
    {
        return true;
    }
    return false;
}
int polyfold::get_next_loop_edge_going_right(int f_i, int e_i, int v_i)
{
    int ret;
    std::vector<int> links_ = get_edges_from_point(f_i,e_i,v_i);

    std::vector<int> links;
    for(int i: links_)
        if(this->edges[i].p2 != -1)
            links.push_back(i);

    if(links.size()==1)
    {
        ret = links[0];
    }
    else if(links.size() > 1)
    {
        std::vector<core::vector3df> vecs;
        for(int e_j : links)
        {
            int v_j = this->get_opposite_end(e_j,v_i);
            vecs.push_back(this->vertices[v_j].V - this->vertices[v_i].V);
        }

        core::vector3df straight_ahead = this->vertices[v_i].V - this->vertices[this->get_opposite_end(e_i,v_i)].V;

        for(int i=0; i<links.size()-1; i++)
            for(int j=i+1; j<links.size(); j++)
            {
                if(is_left_from2(vecs[j],vecs[i],straight_ahead, this->faces[f_i].getOrientingNormal()))
                {
                    core::vector3df tv = vecs[i];
                    vecs[i]=vecs[j];
                    vecs[j]= tv;

                    int ti = links[i];
                    links[i]=links[j];
                    links[j]=ti;
                }
            }
        ret = links[links.size()-1];
    }
    else
        ret = -1;

    return ret;
}


std::vector<int> polyfold::get_loop_going_right(int f_i, int v_0, int e_0, int v_1, LineHolder& graph)
{
    std::vector<int> e_loop;
    e_loop.push_back(e_0);

    int v_i = v_1;
    int e_i = e_0;

    while(true)
    {
        e_i = get_next_loop_edge_going_right(f_i,e_i,v_i);

        if(e_i == -1)
            {
                std::cout<<"*Error calc loops search space zero\n";
                return e_loop;
            }

        if(e_i==e_0)
            return e_loop;

       // std::cout<<e_i<<"\n";

        v_i = this->get_opposite_end(e_i,v_i);


        e_loop.push_back(e_i);
    };
}

std::vector<int> polyfold::search_connected_edges(polyfold &pf, int f_i, int e_0)
{
    std::vector<int> ret;
    ret.push_back(e_0);

    int v0=this->edges[e_0].v0;
    int v1=this->edges[e_0].v1;

    std::vector<int> links = this->get_edges_from_point(f_i,e_0,v0);
    for(int e_i : links)
    {
        int w0 = pf.get_point_or_add(this->getVertex(e_i,0).V);
        int w1 = pf.get_point_or_add(this->getVertex(e_i,1).V);
        if(pf.find_edge(w0,w1) == -1)
        {
            int new_e = pf.get_edge_or_add(w0,w1,0);
            std::vector<int> res = search_connected_edges(pf,f_i,e_i);
            for(int i: res)
                ret.push_back(i);
        }
    }

    links = this->get_edges_from_point(f_i,e_0,v1);
    for(int e_i : links)
    {
        int w0 = pf.get_point_or_add(this->getVertex(e_i,0).V);
        int w1 = pf.get_point_or_add(this->getVertex(e_i,1).V);
        if(pf.find_edge(w0,w1) == -1)
        {
            int new_e = pf.get_edge_or_add(w0,w1,0);
            std::vector<int> res = search_connected_edges(pf,f_i,e_i);
            for(int i: res)
                ret.push_back(i);
        }
    }
    return ret;
}

std::vector<int> polyfold::get_all_connected_edges(int f_i, int e_0)
{
    polyfold pf;
    int v0 = pf.get_point_or_add(this->getVertex(e_0,0).V);
    int v1 = pf.get_point_or_add(this->getVertex(e_0,1).V);
    pf.get_edge_or_add(v0,v1,0);

    return this->search_connected_edges(pf,f_i,e_0);
}

void polyfold::do_loops(int f_i, int e_0, LineHolder& graph)
{
    LineHolder nograph;
    int v0 = this->edges[e_0].v0;
    int v1 = this->edges[e_0].v1;

   // std::cout<<"f "<<f_i<<" e "<<e_0<<"\n";

   //std::cout<<"e_0="<<e_0<<" v0="<<v0<<" v1="<<v1<<" ";
    if(this->edges[e_0].p2 == 0 || this->edges[e_0].p2 == 2)
    {
        ///std::cout<<"a\n";
        std::vector<int> res = get_loop_going_right(f_i,v0,e_0,v1,nograph);
        //std::cout<<"right res: ";
        //for(int i=0;i<res.size();i++)
        //    std::cout<<res[i]<<" ";
        //std::cout<<"\n";
        this->add_loop_from_edges(f_i,res,false);
    }
    if(this->edges[e_0].p2 == 1)
    {
        //std::cout<<"b\n";
        std::vector<int> res = get_loop_going_left(f_i,v0,e_0,v1,nograph);
        //std::cout<<"left res: ";
        //for(int i=0;i<res.size();i++)
        //    std::cout<<res[i]<<" ";
        //std::cout<<"\n";
        this->add_loop_from_edges(f_i,res,true);
    }

    //0- unexplored
    //1- v0 to v1 going right = v1 to v0 going left
    //2- v1 to v0 going right = v0 to v1 going left
    //3- both
}

void polyfold::meld_loops(int f_i, bool cull_inner_loops)
{
    for(int e_i: this->faces[f_i].edges)
        this->edges[e_i].p2 = 0;

    for(int p=0;p<this->faces[f_i].loops.size();p++)
    {
        this->set_loop_solid(f_i,p);

        std::vector<int> tempv = this->faces[f_i].loops[p].vertices;
        tempv.push_back(tempv[0]);

        for(int i=0;i<tempv.size()-1;i++)
        {
          int e_i = this->find_edge(tempv[i],tempv[i+1]);

          if(tempv[i] == this->edges[e_i].v0) //v0 to v1
            {
                if(this->edges[e_i].p2 == 0)
                    this->edges[e_i].p2 = 1;
                else if(this->edges[e_i].p2 == 2)
                    this->edges[e_i].p2 = 3;
            }
            else //v1 to v0
            {
                if(this->edges[e_i].p2 == 0)
                    this->edges[e_i].p2 = 2;
                else if(this->edges[e_i].p2 == 1)
                    this->edges[e_i].p2 = 3;
            }
        }
    }

    std::vector<int> new_edges;

    for(int e_i: this->faces[f_i].edges)
    {
        if(this->edges[e_i].p2 == 1 || this->edges[e_i].p2 == 2)
            new_edges.push_back(e_i);
    }

    this->faces[f_i].edges = new_edges;

    for(int e_0 : this->faces[f_i].edges)
        {
            if(this->edges[e_0].p2==1)
                this->edges[e_0].p2=2;
            else if(this->edges[e_0].p2==2)
                this->edges[e_0].p2=1;
        }

    this->faces[f_i].loops.clear();

    LineHolder nograph;
    for(int e_0 : this->faces[f_i].edges)
    {
        if(this->edges[e_0].p2 < 3 && this->edges[e_0].p2 != -1 && this->edges[e_0].topo_group != -1)
        {
            this->do_loops(f_i,e_0,nograph);
        }
    }

    if(cull_inner_loops)
        for(int p=0;p<this->faces[f_i].loops.size();p++)
        {
            if(this->faces[f_i].loops[p].type == LOOP_OUTER)
            {
                std::cout<<"meld loops, cleared one outer loop, face "<<f_i<<"\n";
                this->faces[f_i].loops[p].vertices.clear();
            }
        }

}

void polyfold::calc_loops4(int f_i, LineHolder& graph)
{
    for(poly_edge &edge: this->edges)
        edge.p2= -1;//edge.perimeter;

    LineHolder nograph;

    this->faces[f_i].loops.clear();

    for(int e_0 : this->faces[f_i].edges)
    {
        if(this->edges[e_0].p2 == -1 && this->edges[e_0].topo_group != -1)
        {
            std::vector<int> evec = this->get_all_connected_edges(f_i,e_0);
            for(int e_i : evec)
            {
                this->edges[e_i].p2 = 0;
            }
        }
    }

    bool found_loose_end;
    int n_loose_ends=0;
   // if(false)
    do
    {
        found_loose_end = false;
        for(int e_0 : this->faces[f_i].edges)
        {
            if(this->edges[e_0].p2 != -1)
            {
                bool ok0=false;
                bool ok1=false;

                std::vector<int> evec0 = this->get_all_edges_from_point(e_0,this->edges[e_0].v0);
                std::vector<int> evec1 = this->get_all_edges_from_point(e_0,this->edges[e_0].v1);

                for(int e_i : evec0)
                {
                    if(this->edges[e_i].p2 != -1)
                        ok0=true;
                }

                for(int e_i : evec1)
                {
                    if(this->edges[e_i].p2 != -1)
                        ok1=true;
                }

                if(ok0 == false || ok1 == false)
                {
                    this->edges[e_0].p2=-1;
                    found_loose_end=true;
                    n_loose_ends++;
                }
            }
        }
    } while(found_loose_end == true);

    if(n_loose_ends>0) std::cout<<" Calc Loops: cleaned up "<<n_loose_ends<<" loose ends\n";


    for(int e_0 : this->faces[f_i].edges)
    {
        if(this->edges[e_0].p2 < 3 && this->edges[e_0].p2 != -1 && this->edges[e_0].topo_group != -1)
        {
            this->do_loops(f_i,e_0,graph);
        }
    }
}

void polyfold::add_loop_from_edges(int f_i, std::vector<int> e_vec, bool is_left)
{
    if(e_vec.size()>0)
    {
        poly_loop loop;
        int v0;
        if(this->edges[e_vec[0]].v0 == this->edges[e_vec[1]].v0 || this->edges[e_vec[0]].v0 == this->edges[e_vec[1]].v1)
            v0 = this->edges[e_vec[0]].v1;
        else
            v0 = this->edges[e_vec[0]].v0;

            //0- unexplored
            //1- v0 to v1 going right = v1 to v0 going left
            //2- v1 to v0 going right = v0 to v1 going left
            //3- both explored

        for(int e_i : e_vec)
            {
            loop.vertices.push_back(v0);
            if(is_left == false) //going right
            {
                if(v0 == this->edges[e_i].v0) //v0 to v1
                {
                    if(this->edges[e_i].p2 == 0)
                        this->edges[e_i].p2 = 1;
                    else if(this->edges[e_i].p2 == 2)
                        this->edges[e_i].p2 = 3;
                }
                else //v1 to v0
                {
                    if(this->edges[e_i].p2 == 0)
                        this->edges[e_i].p2 = 2;
                    else if(this->edges[e_i].p2 == 1)
                        this->edges[e_i].p2 = 3;
                }
            }
            else //going left
            {
                if(v0 == this->edges[e_i].v0) //v0 to v1
                {
                    if(this->edges[e_i].p2 == 0)
                        this->edges[e_i].p2 = 2;
                    else if(this->edges[e_i].p2 == 1)
                        this->edges[e_i].p2 = 3;
                }
                else //v1 to v0
                {
                    if(this->edges[e_i].p2 == 0)
                        this->edges[e_i].p2 = 1;
                    else if(this->edges[e_i].p2 == 2)
                        this->edges[e_i].p2 = 3;
                }
            }
            v0 = get_opposite_end(e_i,v0);
            }

        this->faces[f_i].loops.push_back(loop);

        int new_p = this->faces[f_i].loops.size()-1;

        this->calc_loop_bbox(f_i,new_p);
        if( fabs(this->faces[f_i].loops[new_p].max_x - this->faces[f_i].loops[new_p].min_x<0.5) ||
            fabs(this->faces[f_i].loops[new_p].max_z - this->faces[f_i].loops[new_p].min_z<0.5))
            std::cout<<"*error bad loop "<<f_i<<","<<new_p<<"\n";

        bool bCW = this->is_clockwise_loop(f_i,new_p);

        if((bCW && is_left == false) || (!bCW && is_left == true))
            this->faces[f_i].loops[new_p].type = LOOP_INNER;
        else
            this->faces[f_i].loops[new_p].type = LOOP_OUTER;
            /*
        if(f_i==0)
        //if(false)
        {
        std::cout<<"f "<<f_i<<" loop "<<this->faces[f_i].loops.size()<<" ";

        if(is_left) std::cout<<" is_left=true ";
        else std::cout<<" is_left=false ";

        if(bCW) std::cout<<"bCW = true\n";
        else std::cout<<"bCW = false\n";
        }
        */

    }
}

//==============================================================================


bool polyfold::apply_topology_groups(int default_group)
{
    std::vector<int> c_edges;
    int counts=0;
    bool found_one;
    while(this->exists_topology_group(2))
    {
        found_one=false;
        for(int e_i = 0; e_i<this->edges.size(); e_i++)
        {
            poly_edge edge = this->edges[e_i];

            if(edge.topo_group==2)
            {
                int v0 = edge.v0;
                int v1 = edge.v1;
                bool safe = true;
                bool found = false;

                c_edges = this->get_all_edges_from_point(e_i,v0);
                for(int e_j : c_edges)
                {
                    if(this->edges[e_j].topo_group == 3)
                        safe=false;
                }

                if(safe)
                    for(int e_j : c_edges)
                    {
                        if(this->edges[e_j].topo_group == 0 || this->edges[e_j].topo_group == 1)
                        {
                            this->edges[e_i].topo_group = this->edges[e_j].topo_group;
                            found=true;
                            found_one=true;
                        }
                    }

                if(!found)
                {
                    safe=true;
                    c_edges = this->get_all_edges_from_point(e_i,v1);
                    for(int e_j : c_edges)
                    {
                        if(this->edges[e_j].topo_group == 3)
                            safe=false;
                    }

                    if(safe)
                        for(int e_j : c_edges)
                        {
                            if(this->edges[e_j].topo_group == 0 || this->edges[e_j].topo_group == 1)
                            {
                                this->edges[e_i].topo_group = this->edges[e_j].topo_group;
                                found_one=true;
                            }
                        }
                }
            }
        }
        if(!found_one)
        {
            std::cout<<" no intersections... using default value\n";
            return false;
        }
    }
    return true;
}

void polyfold::propagate_topo_group(int e_i, int v0)
{
    int v1 = this->get_opposite_end(e_i,v0);
    bool safe=true;

    std::vector<int> c_edges = this->get_all_edges_from_point(e_i,v1);

    for(int e_j : c_edges)
        {
            if(this->edges[e_j].topo_group == 3)
                safe=false;
        }

    if(safe)
    {
        for(int e_j : c_edges)
            if(this->edges[e_j].topo_group == 2)
            {
                this->edges[e_j].topo_group = this->edges[e_i].topo_group;
                this->propagate_topo_group(e_j,v1);
            }
    }

}

bool polyfold::apply_topology_groups3(polyfold& pf2, int default_group)
{
    bool found_one;
    do
    {
        found_one=false;
        for(int e_i = 0; e_i<this->edges.size(); e_i++)
            {
                if(this->edges[e_i].topo_group==2)
                {
                    found_one=true;

                    core::vector3df v0 = this->getVertex(e_i,0).V;
                    core::vector3df v1 = this->getVertex(e_i,1).V;

                    int RES = pf2.classify_point(v0+(v1-v0)*0.5);

                    if(RES == TOP_FRONT)
                    {
                        this->edges[e_i].topo_group=0;
                        std::cout<<"FRONT\n";
                    }
                    else if(RES == TOP_BEHIND)
                    {
                        this->edges[e_i].topo_group=1;
                        std::cout<<"BEHIND\n";
                    }
                    else if(RES == TOP_UNDEF)
                    {
                        if(pf2.topology == TOP_CONCAVE)
                        {
                            this->edges[e_i].topo_group = TOP_BEHIND;
                            std::cout<<"BEHIND (default)\n";
                        }
                        else if(pf2.topology == TOP_CONVEX)
                        {
                            this->edges[e_i].topo_group = TOP_FRONT;
                            std::cout<<"FRONT (default)\n";
                        }
                    }

                    this->propagate_topo_group(e_i,v0);
                    this->propagate_topo_group(e_i,v1);
                }
            }
    } while(found_one==true);

    return true;
}


bool polyfold::apply_topology_groups2(polyfold& pf2, int default_group)
{
    std::vector<int> c_edges;
    int counts=0;
    bool found_one;
    while(this->exists_topology_group(2))
    {
        found_one=false;
        for(int e_i = 0; e_i<this->edges.size(); e_i++)
        {
            poly_edge edge = this->edges[e_i];

            if(edge.topo_group==2)
            {
                int v0 = edge.v0;
                int v1 = edge.v1;
                bool safe = true;
                bool found = false;

                c_edges = this->get_all_edges_from_point(e_i,v0);
                for(int e_j : c_edges)
                {
                    if(this->edges[e_j].topo_group == 3)
                        safe=false;
                }

                if(safe)
                    for(int e_j : c_edges)
                    {
                        if(this->edges[e_j].topo_group == 0 || this->edges[e_j].topo_group == 1)
                        {
                            this->edges[e_i].topo_group = this->edges[e_j].topo_group;
                            found=true;
                            found_one=true;
                        }
                    }

                if(!found)
                {
                    safe=true;
                    c_edges = this->get_all_edges_from_point(e_i,v1);
                    for(int e_j : c_edges)
                    {
                        if(this->edges[e_j].topo_group == 3)
                            safe=false;
                    }

                    if(safe)
                        for(int e_j : c_edges)
                        {
                            if(this->edges[e_j].topo_group == 0 || this->edges[e_j].topo_group == 1)
                            {
                                this->edges[e_i].topo_group = this->edges[e_j].topo_group;
                                found_one=true;
                            }
                        }
                }
            }
        }
        if(!found_one)
        {
            for(int e_i = 0; e_i<this->edges.size(); e_i++)
            {
                poly_edge edge = this->edges[e_i];

                if(edge.topo_group==2)
                {
                    core::vector3df v0 = this->getVertex(e_i,0).V;
                    core::vector3df v1 = this->getVertex(e_i,1).V;
                    int RES = pf2.classify_point(v0+(v1-v0)*0.5);
                    if(RES == TOP_FRONT)
                    {
                        this->edges[e_i].topo_group=0;
                        found_one=true;
                        std::cout<<"FRONT\n";
                    }
                    else if(RES == TOP_BEHIND)
                    {
                        this->edges[e_i].topo_group=1;
                        found_one=true;
                        std::cout<<"BEHIND\n";
                    }
                    else if(RES == TOP_UNDEF)
                    {
                        if(pf2.topology == TOP_CONCAVE)
                        {
                            this->edges[e_i].topo_group = TOP_BEHIND;
                            std::cout<<"BEHIND (default)\n";
                        }
                        else if(pf2.topology == TOP_CONVEX)
                        {
                            this->edges[e_i].topo_group = TOP_FRONT;
                            std::cout<<"FRONT (default)\n";
                        }
                        found_one=true;
                    }
                    //else std::cout<<"UNDEF\n";
                }
                if(found_one)
                    break;
            }
        if(!found_one)
            {
               // std::cout<<" no intersections... using default value\n";
                return false;
            }
        }
    }
    return true;
}

void polyfold::simplify_edges()
{

    std::cout<<"simplifying edges...\n";
    simp_try_again:

    for(int f_i=0;f_i<this->faces.size();f_i++)
    {
        for(int p_i = 0; p_i< this->faces[f_i].loops.size(); p_i++)
        {
            std::vector<int> tempv = this->faces[f_i].loops[p_i].vertices;
            tempv.push_back(tempv[0]);
            tempv.push_back(tempv[1]);

            for(int i=0; i < tempv.size()-2; i++)
               {

                    core::line3df line(this->vertices[tempv[i]].V,this->vertices[tempv[i+2]].V);
                    core::vector3df r = line.getClosestPoint(this->vertices[tempv[i+1]].V);
                    f32 d = r.getDistanceFrom(this->vertices[tempv[i+1]].V);
                    if(d<0.01)
                    {
                        int mid = (i+1)%this->faces[f_i].loops[p_i].vertices.size();
                        std::cout<<"remove "<<mid<<" from loop "<<p_i<<"\n";

                        std::vector<int> new_loop;
                        for(int j=0; j<this->faces[f_i].loops[p_i].vertices.size(); j++)
                        {
                            if(j != mid)
                                new_loop.push_back(this->faces[f_i].loops[p_i].vertices[j]);
                        }
                        this->faces[f_i].loops[p_i].vertices = new_loop;

                        goto simp_try_again;
                    }
               }
        }
    }
}

void polyfold::reduce_edges_vertices2()
{
    int v_size = this->vertices.size();
    int e_size = this->edges.size();

    std::vector<poly_vert> old_verts = this->vertices;

    this->edges.clear();
    this->vertices.clear();

    for(int f_i=0;f_i<this->faces.size();f_i++)
    {
        this->faces[f_i].edges.clear();
        this->faces[f_i].vertices.clear();

        std::vector<poly_loop> new_loops;
        for(int p_i = 0; p_i< this->faces[f_i].loops.size(); p_i++)
        {
            if(this->faces[f_i].loops[p_i].vertices.size()>2)
                new_loops.push_back(this->faces[f_i].loops[p_i]);
        }

        this->faces[f_i].loops = new_loops;

        for(int p_i = 0; p_i< this->faces[f_i].loops.size(); p_i++)
        {
            std::vector<int> tempv = this->faces[f_i].loops[p_i].vertices;
            tempv.push_back(tempv[0]);

            for(int i=0; i < tempv.size()-1; i++)
               {
                int v0 = this->get_point_or_add(old_verts[tempv[i]].V);
                int v1 = this->get_point_or_add(old_verts[tempv[i+1]].V);
                this->faces[f_i].addVertex(v0);
                this->faces[f_i].addVertex(v1);

                int e_i = this->get_edge_or_add(v0,v1,0);
                this->faces[f_i].addEdge(e_i);
               }

            std::vector<int> new_loop;

            for(int i=0; i < this->faces[f_i].loops[p_i].vertices.size(); i++)
            {
                new_loop.push_back(this->find_point(old_verts[this->faces[f_i].loops[p_i].vertices[i]].V));
            }

            this->faces[f_i].loops[p_i].vertices = new_loop;
        }
    }

   // std::cout<<"edges reduced from "<<e_size<<" to "<<this->edges.size()<<", vertices reduced from "<<v_size<<" to "<<this->vertices.size()<<"\n";
}


void polyfold::clear_ghost_loops()
{
    for(poly_face &f : this->faces)
        for(poly_loop &p : f.loops)
            if(p.topo_group == LOOP_HOLLOW && p.depth%2 ==0)
                p.vertices.clear();
}


bool is_identical_loop(polyfold pf, poly_loop loop_a , polyfold pf2, poly_loop loop_b)
{
    if(loop_a.vertices.size() == loop_b.vertices.size())
    {
        for(int v_i : loop_a.vertices)
        {
            bool b = false;
            for(int v_j : loop_b.vertices)
            {
                if(is_same_point(pf.vertices[v_i].V,pf2.vertices[v_j].V)==true)
                    b= true;
            }
            if(!b)
                return false;
        }
        return true;
    }
    return false;
}


bool is_contained_loop(polyfold &pf, poly_loop &loop_a , polyfold &pf2, int f_j, int p_j)
{
    std::vector<int> tempv = loop_a.vertices;
    tempv.push_back(tempv[0]);

    for(int i=0; i < tempv.size()-1; i++)
        {
            bool b = false;
            core::vector3df v0 = pf.vertices[tempv[i]].V;
            core::vector3df v1 = pf.vertices[tempv[i+1]].V;
            core::vector3df V = v0+(v1-v0)*0.5;

            if(pf2.is_point_in_loop(f_j,p_j,V))
                b= true;

            if(!b)
            {
                return false;
            }
        }
    return true;
}


bool polyfold::is_inner_loop(int f_i, int p_i, int p_j)
{
    if(this->faces[f_i].loops[p_i].vertices.size() == 0 ||
       this->faces[f_i].loops[p_j].vertices.size() == 0)
        return false;

    std::vector<int> tempv = this->faces[f_i].loops[p_i].vertices;
    tempv.push_back(tempv[0]);

    for(int i=0; i < tempv.size()-1; i++)
        {
            bool b = false;
            core::vector3df v0 = this->vertices[tempv[i]].V;
            core::vector3df v1 = this->vertices[tempv[i+1]].V;
            core::vector3df V = v0+(v1-v0)*0.5;

            if(this->is_point_in_loop(f_i,p_j,V))
                b= true;

            if(!b)
            {
                return false;
            }
        }
    return true;
}
