
#include <irrlicht.h>
#include "CMeshSceneNode.h"
#include "BufferManager.h"
#include "csg_classes.h"
#include "geometry_scene.h"
#include "material_groups.h"

using namespace irr;
using namespace scene;



MeshNode_Interface::MeshNode_Interface(scene::ISceneManager* smgr_,video::IVideoDriver* driver_,MyEventReceiver* receiver, video::E_MATERIAL_TYPE base_material_type_, video::E_MATERIAL_TYPE special_material_type_)
{
    this->smgr = smgr_;
    this->driver = driver_;
    this->base_material_type = base_material_type_;
    this->special_material_type = special_material_type_;
    this->event_receiver = receiver;
}

MeshNode_Interface::MeshNode_Interface()
{
}

void MeshNode_Interface::init(scene::ISceneManager* smgr_,video::IVideoDriver* driver_,MyEventReceiver* receiver, video::E_MATERIAL_TYPE base_material_type_, video::E_MATERIAL_TYPE special_material_type_)
{
    this->smgr = smgr_;
    this->driver = driver_;
    this->base_material_type = base_material_type_;
    this->special_material_type = special_material_type_;
    this->event_receiver = receiver;
}

MeshNode_Interface::~MeshNode_Interface()
{
    if(this->m_mesh)
        this->m_mesh->drop();
}

void MeshNode_Interface::generate_mesh_node(geometry_scene* geo_scene)
{
    if(m_mesh)
        m_mesh->drop();

    this->m_mesh = new scene::SMesh;
    materials_used.clear();
    mg_to_reference_face.clear();

    polyfold* pf = geo_scene->get_total_geometry();

    for(int f_i =0 ;f_i<pf->faces.size(); f_i++)
    {
        int brush_j = geo_scene->get_total_geometry()->faces[f_i].original_brush;
        int face_j = geo_scene->get_total_geometry()->faces[f_i].original_face;

        pf->faces[f_i].material_group = geo_scene->elements[brush_j].brush.faces[face_j].material_group;
    }

    for(int f_i =0 ;f_i<pf->faces.size(); f_i++)
    {

        video::ITexture* tex_j = driver->getTexture(pf->faces[f_i].texture_name.c_str());

        bool b=false;

        for(TextureMaterial tm: materials_used)
        {
            if(tm.texture == tex_j && tm.materialGroup == pf->faces[f_i].material_group)
                b= true;
        }
        if(!b)
        {
            materials_used.push_back(TextureMaterial{tex_j,pf->faces[f_i].material_group});
            mg_to_reference_face.push_back(f_i);
        }
    }

    this->generate_mesh_buffer(geo_scene,m_mesh);

    this->generate_uvs(geo_scene);
}

CMeshSceneNode* MeshNode_Interface::addMeshSceneNode(scene::ISceneManager* smgr0,geometry_scene* geo_scene)
{
    if(this->m_mesh && smgr0)
    {
        CMeshSceneNode* mesh_node = new scene::CMeshSceneNode(this->m_mesh,smgr0->getRootSceneNode(),smgr0,747);
        mesh_node->SetBox(geo_scene->get_total_geometry()->bbox);
        mesh_node->setVisible(true);
        return mesh_node;
    }

    return NULL;
}

void MeshNode_Interface_Edit::generate_mesh_buffer(geometry_scene* geo_scene, SMesh* mesh)
{
    scene::SMeshBuffer* buffer;

    int b_count=0;
    int i_count=0;
    int v_count=0;
    LineHolder nograph;

    face_to_mb_buffer.clear();

    polyfold* pf = geo_scene->get_total_geometry();

    for(int f_i =0; f_i<pf->faces.size(); f_i++)
    {
        if(pf->faces[f_i].loops.size()==0)
        {
            this->face_to_mb_buffer.push_back(-1);
            continue;
        }

        this->face_to_mb_buffer.push_back(b_count);

        std::vector<triangle_holder> triangles;

        triangle_holder th = pf->trianglize(f_i,NULL,nograph,nograph);

        triangles.push_back(th);

        buffer = new scene::SMeshBuffer();
        buffer->Material.setTexture(0,driver->getTexture(pf->faces[f_i].texture_name.c_str()));
        geo_scene->getMaterialGroupsBase()->apply_material_to_buffer(buffer,pf->faces[f_i].material_group);

        make_meshbuffer_from_triangles(triangles,buffer);
        mesh->addMeshBuffer(buffer);

        b_count++;
        i_count+=buffer->Indices.size();
        v_count+=buffer->Vertices.size();

        //pf.faces[f_i].temp_b = false;
    }
     std::cout<<""<<b_count<<" buffers with "<<v_count<<" vertices and "<<i_count/3<<" triangles... done\n";
}

void MeshNode_Interface::recalc_uvs_for_face_cube(polyfold* pf, poly_face* f, int f_i)
{
    MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(f_i);

    if(chunk.buffer)
    {
        calculate_meshbuffer_uvs_cube(pf,f, chunk.buffer, chunk.begin_i, chunk.end_i);
    }
}

void MeshNode_Interface::recalc_uvs_for_face_cylinder(polyfold* pf, poly_face* f, int f_i)
{
    MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(f_i);

    if(chunk.buffer)
    {
        calculate_meshbuffer_uvs_cylinder(pf,f, chunk.buffer, chunk.begin_i, chunk.end_i);
    }
}

void MeshNode_Interface::recalc_uvs_for_face_sphere(polyfold* pf, poly_face* f, int f_i)
{
    MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(f_i);

    if(chunk.buffer)
    {
        calculate_meshbuffer_uvs_sphere(pf,f, chunk.buffer, chunk.begin_i, chunk.end_i);
    }
}

void MeshNode_Interface::recalc_uvs_for_face_dome(polyfold* pf, poly_face* f, int f_i)
{
    MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(f_i);

    if(chunk.buffer)
    {
        calculate_meshbuffer_uvs_dome(pf,f, chunk.buffer, chunk.begin_i, chunk.end_i);
    }
}

void MeshNode_Interface::generate_uvs(geometry_scene* geo_scene)
{
    for(int i=1; i<geo_scene->elements.size();i++)
        for(int f_i=0; f_i<geo_scene->elements[i].brush.faces.size(); f_i++)
            geo_scene->elements[i].brush.faces[f_i].temp_b=false;

    polyfold* pf = geo_scene->get_total_geometry();

    for(int f_i = 0; f_i<pf->faces.size(); f_i++)
    {

        if(pf->faces[f_i].loops.size()>0)
        {
            poly_face* f = geo_scene->get_original_brush_face(f_i);
            polyfold* brush = geo_scene->get_original_brush(f_i);

            std::vector<int> surface;

            if(f->temp_b==false)
            {
                switch(brush->surface_groups[ f->surface_group ].type)
                {
                case SURFACE_GROUP_STANDARD:
                    {
                        MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(f_i);

                        if(chunk.buffer)
                        {
                           // std::cout<<"S chunk:  "<<chunk.begin_i<<" , "<<chunk.end_i<<"\n";
                            calculate_meshbuffer_uvs_cube(brush,f, chunk.buffer, chunk.begin_i, chunk.end_i);
                        }
                        f->temp_b = true;
                    } break;
                case SURFACE_GROUP_CYLINDER:
                    {
                        surface = geo_scene->getSurfaceFromFace(f_i);
                        for(int b_i : surface)
                        {
                            poly_face* ff = geo_scene->get_original_brush_face(b_i);
                            polyfold* brush1 = geo_scene->get_original_brush(b_i);

                            if(ff->temp_b == false)
                            {
                                MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(b_i);

                                if(chunk.buffer)
                                {
                                 //   std::cout<<"chunk:  "<<chunk.begin_i<<" , "<<chunk.end_i<<"\n";
                                    calculate_meshbuffer_uvs_cylinder(brush1,ff, chunk.buffer, chunk.begin_i, chunk.end_i);
                                }

                                ff->temp_b = true;
                            }
                        }

                    } break;
                case SURFACE_GROUP_SPHERE:
                    {
                        surface = geo_scene->getSurfaceFromFace(f_i);
                        for(int b_i : surface)
                        {
                            poly_face* ff = geo_scene->get_original_brush_face(b_i);
                            polyfold* brush1 = geo_scene->get_original_brush(b_i);

                            if(ff->temp_b == false)
                            {
                                MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(b_i);

                                if(chunk.buffer)
                                {
                                   // std::cout<<"chunk:  "<<chunk.begin_i<<" , "<<chunk.end_i<<"\n";
                                    calculate_meshbuffer_uvs_sphere(brush1,ff, chunk.buffer, chunk.begin_i, chunk.end_i);
                                }

                                ff->temp_b = true;
                            }
                        }

                    } break;
                case SURFACE_GROUP_DOME:
                    {
                        surface = geo_scene->getSurfaceFromFace(f_i);
                        for(int b_i : surface)
                        {
                            poly_face* ff = geo_scene->get_original_brush_face(b_i);
                            polyfold* brush1 = geo_scene->get_original_brush(b_i);

                            if(ff->temp_b == false)
                            {
                                MeshBuffer_Chunk chunk = get_mesh_buffer_by_face(b_i);

                                if(chunk.buffer)
                                {
                                    calculate_meshbuffer_uvs_dome(brush1,ff, chunk.buffer, chunk.begin_i, chunk.end_i);
                                }

                                ff->temp_b = true;
                            }
                        }

                    } break;
                }//switch
            }
        }
    }
}

int MeshNode_Interface_Edit::get_buffer_index_by_face(int i)
{
    if(i<face_to_mb_buffer.size())
    {
        return face_to_mb_buffer[i];
    }
    return -1;
}

MeshBuffer_Chunk MeshNode_Interface_Edit::get_mesh_buffer_by_face(int i)
{
    MeshBuffer_Chunk ret;

    if(i<face_to_mb_buffer.size())
    {
        int idx = face_to_mb_buffer[i];
        if(idx !=-1 )
        {
            ret.buffer = this->m_mesh->getMeshBuffer(idx);
            ret.begin_i=0;
            ret.end_i=this->m_mesh->getMeshBuffer(idx)->getIndexCount();
            return ret;
        }
    }

    ret.buffer = NULL;

    return ret;
}


MeshBuffer_Chunk MeshNode_Interface_Final::get_mesh_buffer_by_face(int i)
{
    MeshBuffer_Chunk ret;

    if(i<face_to_mb_buffer.size())
    {
        int idx = face_to_mb_buffer[i];
        if(idx !=-1 )
        {
            ret.buffer = this->m_mesh->getMeshBuffer(idx);
            ret.begin_i = face_to_mb_begin[i];
            ret.end_i = face_to_mb_end[i];
            return ret;
        }
    }

    ret.buffer = NULL;

    return ret;
}

/*
void MeshNode_Interface_Final::generate_uvs(geometry_scene* geo_scene)
{

}*/

class trianglizer_base
{
public:
    polyfold* pf = NULL;
    //virtual void init(surface_group, polyfold*);
    virtual triangle_holder get_triangles(std::vector<int>) {triangle_holder th; return th;}
    virtual triangle_holder get_triangles(int) {triangle_holder th; return th;}
};

class trianglizer_vanilla : public trianglizer_base
{
public:
    void init(polyfold* pf_)
    {
        pf = pf_;
    }
    virtual triangle_holder get_triangles(int f_i)
    {
        LineHolder nograph;
        return pf->trianglize(f_i,NULL,nograph,nograph);
    }
};


class trianglizer_sphere : public trianglizer_base
{
public:

    core::vector3df v0;
    core::vector3df iY;
    core::vector3df r0;

    void init(polyfold* pf_,surface_group sfg)
    {
        pf = pf_;

        v0 = sfg.vec1;
        iY = sfg.vec.crossProduct(sfg.vec1);
        iY.normalize();

        r0 = sfg.point;
    }
    virtual triangle_holder get_triangles(std::vector<int> surface)
    {
        LineHolder nograph;
        triangle_holder ret;

        int c0=0;
        int c1=0;

        for(int b_i : surface)
        {
            triangle_holder th = pf->trianglize(b_i,NULL,nograph,nograph);

            std::vector<int> indexes;
            for(int i=0;i<th.vertices.size();i++)
            {
                core::vector3df r = th.vertices[i]-r0;

                core::vector2df k;
                k.X = r.dotProduct(v0);
                k.Y = r.dotProduct(iY);

                f32 theta = k.getAngleTrig();

                if(fabs(theta-360.0)<0.001  ||  fabs(theta) < 0.001)
                {
                    ret.vertices.push_back(th.vertices[i]);
                    indexes.push_back(ret.vertices.size()-1);
                    c1++;
                }
                else
                {
                    indexes.push_back(ret.get_point_or_add( th.vertices[i] ));
                    c0++;
                }
            }

            for(triangle T : th.triangles)
            {
                triangle new_T;
                new_T.A = indexes[T.A];
                new_T.B = indexes[T.B];
                new_T.C = indexes[T.C];
                ret.triangles.push_back(new_T);
            }
            ret.f_index.push_back(th.triangles.size());
        }

        std::cout<<" "<<c0 <<" fungible vertices, "<<c1<<" unique vertices\n";

        return ret;
    }
};

void MeshNode_Interface_Final::generate_mesh_buffer(geometry_scene* geo_scene, SMesh* mesh)
{
    scene::SMeshBuffer* buffer;
    LineHolder nograph;

    polyfold* pf = geo_scene->get_total_geometry();

	std::cout<<"geometry uses "<<materials_used.size()<<" material groups\n";

	this->face_to_mb_buffer.assign(pf->faces.size(),-1);
	this->face_to_mb_begin.assign(pf->faces.size(),0);
	this->face_to_mb_end.assign(pf->faces.size(),0);

	std::cout<< pf->faces.size()<<" faces\n\n";

	trianglizer_sphere tri_sphere;

	int tot_v=0;
	int tot_i=0;

	//========material groups
	for(int t_i=0; t_i<materials_used.size(); t_i++)
    {
        int total_indices=0;

        std::vector<triangle_holder> triangle_groups;
        for(int f_i =0 ;f_i<pf->faces.size(); f_i++)
        {
            if(pf->faces[f_i].loops.size() > 0 && pf->faces[f_i].temp_b==false)
            {
                video::ITexture* tex_j = driver->getTexture(pf->faces[f_i].texture_name.c_str());

                if(tex_j == materials_used[t_i].texture && pf->faces[f_i].material_group == materials_used[t_i].materialGroup)
                {
                    switch(pf->getFaceSurfaceGroup(f_i).type)
                    {
                    case SURFACE_GROUP_STANDARD:
                        {
                            triangle_holder th = pf->trianglize(f_i,NULL,nograph,nograph);
                            triangle_groups.push_back(th);

                            this->face_to_mb_buffer[f_i]=t_i;
                            this->face_to_mb_begin[f_i]=total_indices;
                            this->face_to_mb_end[f_i]=total_indices+th.triangles.size()*3;
                            total_indices+=th.triangles.size()*3;

                            pf->faces[f_i].temp_b=true;
                        } break;
                    case SURFACE_GROUP_DOME:
                    case SURFACE_GROUP_SPHERE:
                        {
                            std::vector<int> sfg = geo_scene->getSurfaceFromFace(f_i);

                            tri_sphere.init(pf,pf->getFaceSurfaceGroup(f_i));
                            triangle_holder th = tri_sphere.get_triangles(sfg);


                            for(int i=0;i<sfg.size();i++)
                            {
                                int b_i = sfg[i];

                                pf->faces[b_i].temp_b=true;
                                this->face_to_mb_buffer[b_i]=t_i;
                                this->face_to_mb_begin[b_i]=total_indices;
                                this->face_to_mb_end[b_i]=total_indices+th.f_index[i]*3;
                                total_indices+=th.f_index[i]*3;
                            }
                            std::cout<<sfg.size()<<" faces in sphere\n";

                            triangle_groups.push_back(th);
                        } break;
                    case SURFACE_GROUP_CYLINDER:
                        {
                            std::vector<int> sfg = geo_scene->getSurfaceFromFace(f_i);

                            tri_sphere.init(pf,pf->getFaceSurfaceGroup(f_i));
                            triangle_holder th = tri_sphere.get_triangles(sfg);

                            for(int i=0;i<sfg.size();i++)
                            {
                                int b_i = sfg[i];

                                pf->faces[b_i].temp_b=true;
                                this->face_to_mb_buffer[b_i]=t_i;
                                this->face_to_mb_begin[b_i]=total_indices;
                                this->face_to_mb_end[b_i]=total_indices+th.f_index[i]*3;

                                total_indices+=th.f_index[i]*3;
                            }

                            std::cout<<sfg.size()<<" faces in cylinder\n";

                            triangle_groups.push_back(th);
                        } break;
                    }
                }
            }
        }

        buffer = new scene::SMeshBuffer();
        buffer->Material.setTexture(0,materials_used[t_i].texture);
        geo_scene->getMaterialGroupsBase()->apply_material_to_buffer(buffer,materials_used[t_i].materialGroup);

        make_meshbuffer_from_triangles(triangle_groups,buffer);

        std::cout<<"buffer "<<t_i<<" has "<<buffer->getVertexCount()<<" vertices and "<<buffer->getIndexCount()<<" indices\n";
        tot_i+=buffer->getIndexCount();
        tot_v+=buffer->getVertexCount();

        mesh->addMeshBuffer(buffer);
    }   //material groups (unique textures used)
    std::cout<<materials_used.size()<<" buffers with "<<tot_v<<" vertices and "<<tot_i<<" indices\n";

}
